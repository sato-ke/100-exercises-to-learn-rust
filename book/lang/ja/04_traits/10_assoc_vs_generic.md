# ジェネリクスと関連型

これまでに学んだ2つのトレイト、`From`と`Deref`の定義を再検討しましょう：

```rust
pub trait From<T> {
    fn from(value: T) -> Self;
}

pub trait Deref {
    type Target;
    
    fn deref(&self) -> &Self::Target;
}
```

どちらも型パラメータを含んでいます。\
`From`の場合、それはジェネリックパラメータ`T`です。\
`Deref`の場合、それは関連型`Target`です。

違いは何でしょうか？なぜ一方を他方よりも使うのでしょうか？

## 最大で一つの実装

deref coercionの動作方法により、与えられた型に対して「ターゲット」型は一つしかありえません。
例：`String`は`str`にのみderefできます。
これは曖昧さを避けるためです：型に対して`Deref`を複数回実装できる場合、
`&self`メソッドを呼び出すときにコンパイラはどの`Target`型を選ぶべきでしょうか？

そのため`Deref`は関連型`Target`を使います。\
関連型は**トレイト実装によって**一意に決定されます。
`Deref`を複数回実装することはできないので、与えられた型に対して一つの`Target`しか
指定できず、曖昧さはありません。

## ジェネリックトレイト

一方で、入力型`T`が異なる限り、型に対して`From`を複数回実装できます。
例えば、`u32`と`u16`の両方を入力型として使用して、`WrappingU32`に対して`From`を実装できます：

```rust
impl From<u32> for WrappingU32 {
    fn from(value: u32) -> Self {
        WrappingU32 { inner: value }
    }
}

impl From<u16> for WrappingU32 {
    fn from(value: u16) -> Self {
        WrappingU32 { inner: value.into() }
    }
}
```

`From<u16>`と`From<u32>`は**異なるトレイト**と見なされるため、これは機能します。\
曖昧さはありません：コンパイラは変換される値の型に基づいてどの実装を使うかを決定できます。

## ケーススタディ：`Add`

最後の例として、標準ライブラリの`Add`トレイトを考えてみましょう：

```rust
pub trait Add<RHS = Self> {
    type Output;
    
    fn add(self, rhs: RHS) -> Self::Output;
}
```

両方のメカニズムを使用しています：

- ジェネリックパラメータ`RHS`（右辺側）があり、デフォルトは`Self`
- 関連型`Output`があり、これは加算の結果の型

### `RHS`

`RHS`は異なる型を一緒に加算できるようにするジェネリックパラメータです。\
例えば、標準ライブラリでこれら2つの実装を見つけるでしょう：

```rust
impl Add<u32> for u32 {
    type Output = u32;
    
    fn add(self, rhs: u32) -> u32 {
      //                      ^^^
      // これは代わりに`Self::Output`と書くこともできます。
      // コンパイラは、ここで指定する型が
      // 上で`Output`に割り当てた型と一致する限り
      // 気にしません。
      // [...]
    }
}

impl Add<&u32> for u32 {
    type Output = u32;
    
    fn add(self, rhs: &u32) -> u32 {
        // [...]
    }
}
```

これにより、次のコードがコンパイルできます：

```rust
let x = 5u32 + &5u32 + 6u32;
```

`u32`が`Add<&u32>`_と_`Add<u32>`を実装しているからです。

### `Output`

`Output`は加算の結果の型を表します。

そもそもなぜ`Output`が必要なのでしょうか？出力として、`Add`を実装する型である`Self`を使うことはできないのでしょうか？
できますが、トレイトの柔軟性を制限するでしょう。標準ライブラリでは、例えば、次の実装を見つけるでしょう：

```rust
impl Add<&u32> for &u32 {
    type Output = u32;

    fn add(self, rhs: &u32) -> u32 {
        // [...]
    }
}
```

トレイトを実装している型は`&u32`ですが、加算の結果は`u32`です。\
`add`が`Self`、つまりこの場合`&u32`を返さなければならない場合、この実装を提供することは不可能[^flexible]でしょう。
`Output`により、`std`は実装者と戻り値の型を分離でき、このケースをサポートできます。

一方で、`Output`はジェネリックパラメータにはなれません。演算の出力型は、
オペランドの型が分かれば一意に決定されなければ**なりません**。そのため関連型です：
実装者とジェネリックパラメータの与えられた組み合わせに対して、`Output`型は一つだけです。

## 結論

要約すると：

- 与えられたトレイト実装に対して型が一意に決定されなければならない場合は、**関連型**を使用します。
- 同じ型に対してトレイトの複数の実装を、異なる入力型で許可したい場合は、**ジェネリックパラメータ**を使用します。

[^flexible]: 柔軟性は無料ではありません：`Output`のためにトレイト定義はより複雑になり、実装者は何を返したいかについて考える必要があります。このトレードオフは、その柔軟性が実際に必要な場合にのみ正当化されます。独自のトレイトを設計する際は、それを心に留めておいてください。