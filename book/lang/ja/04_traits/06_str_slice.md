# 文字列スライス

前の章を通して、`"To-Do"`や`"A ticket description"`のような
**文字列リテラル**がコードで使われているのをかなり見てきました。
それらには常に`.to_string()`や`.into()`の呼び出しが続いていました。なぜなのかを理解する時が来ました！

## 文字列リテラル

生のテキストを二重引用符で囲むことで文字列リテラルを定義します：

```rust
let s = "Hello, world!";
```

`s`の型は`&str`、**文字列スライスへの参照**です。

## メモリレイアウト

`&str`と`String`は異なる型です。それらは交換可能ではありません。\
[前に探求した](../03_ticket_v1/09_heap.md)時の`String`のメモリレイアウトを思い出しましょう。
次を実行すると：

```rust
let mut s = String::with_capacity(5);
s.push_str("Hello");
```

メモリではこのシナリオになります：

```text
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
```

もし覚えていれば、`&String`がメモリでどのようにレイアウトされるかも
[調べました](../03_ticket_v1/10_references_in_memory.md)：

```text
     --------------------------------------
     |                                    |         
+----v----+--------+----------+      +----|----+
| pointer | length | capacity |      | pointer |
|    |    |   5    |    5     |      |         |
+----|----+--------+----------+      +---------+
     |        s                          &s 
     |       
     v       
   +---+---+---+---+---+
   | H | e | l | l | o |
   +---+---+---+---+---+
```

`&String`は、`String`のメタデータが保存されているメモリ位置を指します。\
ポインタを辿ると、ヒープに割り当てられたデータにたどり着きます。特に、文字列の最初のバイト`H`にたどり着きます。

`s`の**部分文字列**を表す型が欲しい場合はどうでしょうか？例えば`Hello`の中の`ello`？

## 文字列スライス

`&str`は文字列への**ビュー**、どこか他の場所に保存されているUTF-8バイトの
シーケンスへの**参照**です。
例えば、次のように`String`から`&str`を作成できます：

```rust
let mut s = String::with_capacity(5);
s.push_str("Hello");
// `String`から文字列スライス参照を作成し、
// 最初のバイトをスキップする
let slice: &str = &s[1..];
```

メモリでは、次のようになります：

```text
                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
```

`slice`はスタック上に2つの情報を保存します：

- スライスの最初のバイトへのポインタ
- スライスの長さ

`slice`はデータを所有しません。ただそれを指すだけです：`String`のヒープ割り当てデータへの**参照**です。\
`slice`がドロップされても、ヒープ割り当てデータは解放されません。なぜなら、それはまだ`s`によって所有されているからです。
そのため`slice`は`capacity`フィールドを持ちません：データを所有しないので、
どのくらいのスペースが割り当てられたかを知る必要がありません。参照するデータにのみ関心があります。

## `&str` vs `&String`

経験則として、テキストデータへの参照が必要な場合は、`&String`よりも`&str`を使いましょう。\
`&str`はより柔軟で、一般的にRustコードでよりイディオマティックと考えられています。

メソッドが`&String`を返す場合、どこかにヒープ割り当てされたUTF-8テキストがあり、
それが返す参照と**正確に一致する**ことを約束しています。\
メソッドが`&str`を返す場合、より多くの自由があります：どこかにテキストデータがあり、
その部分集合が必要なものと一致するため、それへの参照を返すと言っているだけです。