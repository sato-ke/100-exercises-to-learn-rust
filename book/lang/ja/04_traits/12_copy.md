# 値のコピー、パート2

前と同じ例を考えてみましょうが、少しひねりを加えて：`String`ではなく`u32`を型として使用します。

```rust
fn consumer(s: u32) { /* */ }

fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1;
}
```

エラーなしでコンパイルされます！何が起こっているのでしょうか？`.clone()`なしで
後者が動作する`String`と`u32`の違いは何でしょうか？

## `Copy`

`Copy`はRustの標準ライブラリで定義されているもう一つのトレイトです：

```rust
pub trait Copy: Clone { }
```

これは`Sized`と同じように、マーカートレイトです。

型が`Copy`を実装している場合、その型の新しいインスタンスを作成するために`.clone()`を呼び出す必要はありません：
Rustが**暗黙的に**してくれます。\
`u32`は`Copy`を実装する型の例で、そのため上記の例がエラーなしでコンパイルされます：
`consumer(s)`が呼び出されると、Rustは`s`の**ビット単位のコピー**を実行して新しい`u32`インスタンスを作成し、
その新しいインスタンスを`consumer`に渡します。すべて舞台裏で行われ、何もする必要がありません。

## 何が`Copy`できるか？

`Copy`は「自動クローン」と等価ではありませんが、それを含意します。
`Copy`を実装することが許可されるために、型はいくつかの要件を満たさなければなりません。

まず第一に、`Copy`は`Clone`のサブトレイトなので、`Clone`を実装していなければなりません。
これは理にかなっています：Rustが型の新しいインスタンスを_暗黙的に_作成できる場合、
`.clone()`を呼び出すことで_明示的に_新しいインスタンスを作成することもできるはずです。

しかし、それだけではありません。さらにいくつかの条件を満たす必要があります：

1. 型は、メモリ内で占有する`std::mem::size_of`バイトを超えて、追加のリソース（例：ヒープメモリ、ファイルハンドルなど）を管理しない
2. 型は可変参照（`&mut T`）ではない

両方の条件が満たされれば、Rustは元のインスタンスの**ビット単位のコピー**を実行することで
安全に型の新しいインスタンスを作成できます。これはしばしば`memcpy`操作と呼ばれ、
ビット単位のコピーを実行するC標準ライブラリ関数にちなんで名付けられています。

### ケーススタディ1：`String`

`String`は`Copy`を実装しない型です。\
なぜでしょうか？追加のリソース：文字列のデータを格納するヒープ割り当てメモリバッファを管理するからです。

Rustが`String`に`Copy`の実装を許可したと想像してみましょう。\
すると、元のインスタンスのビット単位のコピーを実行して新しい`String`インスタンスが作成される場合、
元のインスタンスと新しいインスタンスの両方が同じメモリバッファを指すことになります：

```text
              s                                 copied_s
+---------+--------+----------+      +---------+--------+----------+
| pointer | length | capacity |      | pointer | length | capacity |
|  |      |   5    |    5     |      |  |      |   5    |    5     |
+--|------+--------+----------+      +--|------+--------+----------+
   |                                    |
   |                                    |
   v                                    |
 +---+---+---+---+---+                  |
 | H | e | l | l | o |                  |
 +---+---+---+---+---+                  |
   ^                                    |
   |                                    |
   +------------------------------------+
```

これは悪いことです！
両方の`String`インスタンスがスコープから外れるときにメモリバッファを解放しようとし、
二重解放エラーにつながります。
同じメモリバッファを指す2つの異なる`&mut String`参照を作成することもでき、
Rustの借用規則に違反します。

### ケーススタディ2：`u32`

`u32`は`Copy`を実装します。実際、すべての整数型がそうです。\
整数は、メモリ内で数値を表すバイト「だけ」です。それ以上のものはありません！
それらのバイトをコピーすれば、別の完全に有効な整数インスタンスが得られます。
悪いことは何も起こりえないので、Rustはそれを許可します。

### ケーススタディ3：`&mut u32`

オーナーシップと可変借用を紹介したとき、1つのルールを非常に明確に述べました：
任意の時点で値の可変借用は_一つ_しかありえません。\
そのため、`u32`は`Copy`を実装していても、`&mut u32`は実装しません。

`&mut u32`が`Copy`を実装していれば、同じ値への複数の可変参照を作成し、
複数の場所で同時にそれを変更できます。
それはRustの借用規則の違反です！
`T`が何であっても、`&mut T`は決して`Copy`を実装しません。

## `Copy`の実装

ほとんどの場合、`Copy`を手動で実装する必要はありません。
次のようにderiveするだけです：

```rust
#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}
```