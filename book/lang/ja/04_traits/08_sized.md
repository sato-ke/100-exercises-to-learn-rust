# `Sized`

deref coercionを調べた後でも、`&str`には見た目以上のものがあります。\
[メモリレイアウトについての前の議論](../03_ticket_v1/10_references_in_memory.md)から、
`&str`がスタック上で単一の`usize`、つまりポインタとして表現されることを期待するのは
合理的だったでしょう。しかし、そうではありません。`&str`はポインタの隣に
いくつかの**メタデータ**を格納します：それが指すスライスの長さです。
[前のセクション](06_str_slice.md)の例に戻ると：

```rust
let mut s = String::with_capacity(5);
s.push_str("Hello");
// `String`から文字列スライス参照を作成し、
// 最初のバイトをスキップする
let slice: &str = &s[1..];
```

メモリでは、次のようになります：

```text
                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
```

何が起こっているのでしょうか？

## 動的サイズ型

`str`は**動的サイズ型**（DST）です。\
DSTは、コンパイル時にサイズが分からない型です。`&str`のような
DSTへの参照を持つ場合は常に、それが指すデータについての追加
情報を含まなければなりません。これは**ファットポインタ**です。\
`&str`の場合、それが指すスライスの長さを格納します。
このコースの残りで、DSTのより多くの例を見るでしょう。

## `Sized`トレイト

Rustの`std`ライブラリは`Sized`と呼ばれるトレイトを定義しています。

```rust
pub trait Sized {
    // これは空のトレイトで、実装するメソッドはありません。
}
```

型は、そのサイズがコンパイル時に分かっている場合`Sized`です。言い換えれば、DSTではありません。

### マーカートレイト

`Sized`は**マーカートレイト**の最初の例です。\
マーカートレイトは、実装が必要なメソッドを要求しないトレイトです。動作を定義しません。
特定のプロパティを持つものとして型を**マーク**することにのみ役立ちます。
そのマークは、特定の動作や最適化を有効にするためにコンパイラによって活用されます。

### 自動トレイト

特に、`Sized`は**自動トレイト**でもあります。\
明示的に実装する必要はありません。コンパイラが型の定義に基づいて
自動的に実装してくれます。

### 例

これまで見てきたすべての型は`Sized`です：`u32`、`String`、`bool`など。

今見たように、`str`は`Sized`ではありません。\
しかし`&str`は`Sized`です！コンパイル時にそのサイズが分かります：2つの`usize`、
ポインタ用に1つ、長さ用に1つです。