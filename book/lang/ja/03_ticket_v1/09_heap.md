# ヒープ

スタックは素晴らしいですが、すべての問題を解決することはできません。コンパイル時にサイズが分からないデータはどうでしょうか？
コレクション、文字列、その他の動的サイズのデータは（完全に）スタック割り当てできません。
そこで**ヒープ**の出番です。

## ヒープアロケーション

ヒープを大きなメモリの塊—巨大な配列として視覚化できます。  
ヒープにデータを格納する必要があるときは、**アロケータ**という特別なプログラムに、ヒープのサブセットを予約するよう要求します。この相互作用（および予約したメモリ）を**ヒープアロケーション**と呼びます。
アロケーションが成功すると、アロケータは予約されたブロックの開始への**ポインタ**を与えます。

## 自動解放なし

ヒープはスタックとは非常に異なる構造になっています。  
ヒープアロケーションは連続していません、ヒープ内のどこにでも配置できます。

```
+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
```

ヒープのどの部分が使用中でどの部分が空いているかを追跡するのはアロケータの仕事です。
ただし、アロケータは割り当てたメモリを自動的に解放しません：それについて意図的である必要があり、もう必要でないメモリを**解放**するためにアロケータを再び呼び出す必要があります。

## パフォーマンス

ヒープの柔軟性にはコストが伴います：ヒープアロケーションはスタックアロケーションより**遅い**です。
はるかに多くの簿記が必要です！  
パフォーマンス最適化に関する記事を読むと、ヒープアロケーションを最小化し、可能な限りスタック割り当てデータを優先するよう頻繁にアドバイスされます。

## `String`のメモリレイアウト

`String`型のローカル変数を作成するとき、
Rustはヒープに割り当てることを余儀なくされます[^empty]：どれだけのテキストを入れるかを事前に知らないので、スタックに適切な量の領域を予約できません。  
しかし、`String`は_完全に_ヒープ割り当てされているわけではなく、いくらかのデータをスタックにも保持します。特に：

- 予約したヒープ領域への**ポインタ**。
- 文字列の**長さ**、つまり文字列に何バイトあるか。
- 文字列の**容量**、つまりヒープに何バイトが予約されているか。

これをよりよく理解するために例を見てみましょう：

```rust
let mut s = String::with_capacity(5);
```

このコードを実行すると、メモリはこのようにレイアウトされます：

```
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
```

最大5バイトのテキストを保持できる`String`を要求しました。  
`String::with_capacity`はアロケータに行き、5バイトのヒープメモリを要求します。アロケータはそのメモリブロックの開始へのポインタを返します。  
ただし、`String`は空です。スタックでは、長さと容量を区別することでこの情報を追跡します：この`String`は最大5バイトを保持できますが、現在は実際のテキストを0バイト保持しています。

`String`にテキストをプッシュすると、状況が変わります：

```rust
s.push_str("Hey");
```

```
      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
```

`s`は今3バイトのテキストを保持しています。その長さは3に更新されましたが、容量は5のままです。
ヒープの5バイトのうち3バイトが文字`H`、`e`、`y`の格納に使用されています。

### `usize`

ポインタ、長さ、容量をスタックに格納するのにどれだけの領域が必要でしょうか？  
実行しているマシンの**アーキテクチャ**によります。

マシンのすべてのメモリ位置には[**アドレス**](https://en.wikipedia.org/wiki/Memory_address)があり、一般的に符号なし整数として表現されます。
アドレス空間の最大サイズ（つまり、マシンがアドレス指定できるメモリの量）によって、この整数は異なるサイズを持つことができます。ほとんどの現代のマシンは32ビットまたは64ビットのアドレス空間を使用しています。

Rustは`usize`型を提供することで、これらのアーキテクチャ固有の詳細を抽象化します：
マシンでメモリをアドレス指定するのに必要なバイト数と同じ大きさの符号なし整数です。
32ビットマシンでは、`usize`は`u32`と同等です。64ビットマシンでは、`u64`と一致します。

容量、長さ、ポインタはすべてRustで`usize`として表現されます[^equivalence]。

### ヒープに対する`std::mem::size_of`なし

`std::mem::size_of`はスタックで型が取る領域の量を返します。
これは**型のサイズ**としても知られています。

> `String`がヒープで管理しているメモリバッファはどうでしょうか？それは
> `String`のサイズの一部ではないのですか？

違います！  
そのヒープアロケーションは`String`が管理している**リソース**です。
コンパイラによって`String`型の一部とは考えられません。

`std::mem::size_of`は型がポインタを介して管理または参照する可能性のある追加のヒープ割り当てデータを知らない（または気にしない）ため、`String`の場合のように、そのサイズを追跡しません。

残念ながら、特定の値が実行時に割り当てているヒープメモリの量を測定する`std::mem::size_of`の同等品はありません。一部の型は
ヒープ使用量を検査するメソッドを提供するかもしれません（例：`String`の`capacity`メソッド）が、Rustには実行時のヒープ使用量を取得するための汎用「API」はありません。  
ただし、メモリプロファイラツール（例：[DHAT](https://valgrind.org/docs/manual/dh-manual.html)
または[カスタムアロケータ](https://docs.rs/dhat/latest/dhat/)）を使用してプログラムのヒープ使用量を検査することができます。

[^empty]: `std`は**空の**`String`（つまり`String::new()`）を作成する場合は割り当てません。
初めてデータをプッシュするときにヒープメモリが予約されます。

[^equivalence]: ポインタのサイズはオペレーティングシステムにも依存します。
特定の環境では、ポインタはメモリアドレスより**大きい**です（例：[CHERI](https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/)）。
Rustはポインタがメモリアドレスと同じサイズであるという簡略化された仮定を立てます。
これは遭遇する可能性のあるほとんどの現代のシステムで真実です。