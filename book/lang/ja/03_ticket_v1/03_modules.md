# モジュール

定義したばかりの`new`メソッドは`Ticket`のフィールド値にいくつかの**制約**を課そうとしています。
しかし、これらの不変条件は本当に適用されているのでしょうか？開発者が`Ticket::new`を通さずに`Ticket`を作成することを防ぐものは何でしょうか？

適切な**カプセル化**を得るには、2つの新しい概念：**可視性**と**モジュール**に精通する必要があります。
モジュールから始めましょう。

## モジュールとは何か？

Rustでは**モジュール**は関連するコードを共通の名前空間（つまり、モジュールの名前）の下でグループ化する方法です。  
すでにモジュールの動作を見たことがあります：コードの正確性を検証する単体テストは`tests`という名前の異なるモジュールで定義されています。

```rust
#[cfg(test)]
mod tests {
    // [...]
}
```

## インラインモジュール

上記の`tests`モジュールは**インラインモジュール**の例です：モジュール宣言（`mod tests`）とモジュールの内容（`{ ... }`内のもの）が隣り合っています。

## モジュールツリー

モジュールはネストすることができ、**ツリー**構造を形成します。  
ツリーのルートは**クレート**自体で、他のすべてのモジュールを含む最上位モジュールです。
ライブラリクレートの場合、ルートモジュールは通常`src/lib.rs`です（その場所がカスタマイズされていない限り）。
ルートモジュールは**クレートルート**とも呼ばれます。

クレートルートはサブモジュールを持つことができ、それらのサブモジュールはさらに独自のサブモジュールを持つことができ、以下同様です。

## 外部モジュールとファイルシステム

インラインモジュールは小さなコード片には便利ですが、プロジェクトが成長するにつれて、コードを複数のファイルに分割したくなるでしょう。親モジュールでは、`mod`キーワードを使用してサブモジュールの存在を宣言します。

```rust
mod dog;
```

`cargo`、Rustのビルドツールは、モジュールの実装を含むファイルを見つける責任があります。  
モジュールがクレートのルート（例：`src/lib.rs`または`src/main.rs`）で宣言されている場合、
`cargo`はファイルが以下のいずれかの名前であることを期待します：

- `src/<module_name>.rs`
- `src/<module_name>/mod.rs`

モジュールが別のモジュールのサブモジュールの場合、ファイルは以下の名前にする必要があります：

- `[..]/<parent_module>/<module_name>.rs`
- `[..]/<parent_module>/<module_name>/mod.rs`

例：`dog`が`animals`のサブモジュールの場合、`src/animals/dog.rs`または`src/animals/dog/mod.rs`。

IDEは、`mod`キーワードを使用して新しいモジュールを宣言する際に、これらのファイルを自動的に作成するのに役立つかもしれません。

## アイテムパスと`use`文

同じモジュールで定義されたアイテムには特別な構文なしでアクセスできます。その名前を使用するだけです。

```rust
struct Ticket {
    // [...]
}

// 同じモジュールにいるので、ここでは`Ticket`を
// どのような方法でも修飾する必要はありません
fn mark_ticket_as_done(ticket: Ticket) {
    // [...]
}
```

異なるモジュールからエンティティにアクセスしたい場合はそうではありません。  
アクセスしたいエンティティを指す**パス**を使用する必要があります。

パスはさまざまな方法で構成できます：

- 現在のクレートのルートから開始、例：`crate::module_1::MyStruct`
- 親モジュールから開始、例：`super::my_function`
- 現在のモジュールから開始、例：`sub_module_1::MyStruct`

`crate`と`super`は両方とも**キーワード**です。  
`crate`は現在のクレートのルートを指し、`super`は現在のモジュールの親を指します。

型を参照するたびに完全なパスを書くのは面倒なことがあります。
生活を楽にするために、`use`文を導入してエンティティをスコープに持ち込むことができます。

```rust
// `MyStruct`をスコープに持ち込む
use crate::module_1::module_2::MyStruct;

// これで`MyStruct`を直接参照できます
fn a_function(s: MyStruct) {
     // [...]
}
```

### スターインポート

単一の`use`文でモジュールからすべてのアイテムをインポートすることもできます。

```rust
use crate::module_1::module_2::*;
```

これは**スターインポート**として知られています。  
現在の名前空間を汚染し、各名前がどこから来るのかを理解するのが困難になり、名前の衝突を引き起こす可能性があるため、一般的には推奨されません。  
それでも、単体テストを書く際など、いくつかのケースでは便利です。テストモジュールのほとんどが`use super::*;`文で始まって、親モジュール（テストされているモジュール）からすべてのアイテムをスコープに持ち込んでいることに気づいたかもしれません。

## モジュールツリーの視覚化

プロジェクトのモジュールツリーを描くのに苦労している場合は、[`cargo-modules`](https://crates.io/crates/cargo-modules)を使用して視覚化してみてください！

インストール手順と使用例については、彼らのドキュメントを参照してください。