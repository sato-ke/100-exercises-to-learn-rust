# メモリレイアウト

所有権と参照を操作的な観点から見てきました—それらで何ができて何ができないか。
今度は内部を見てみる良い時期です：**メモリ**について話しましょう。

## スタックとヒープ

メモリについて議論するとき、人々が**スタック**と**ヒープ**について話すのをよく聞くでしょう。  
これらは、プログラムがデータを格納するために使用する2つの異なるメモリ領域です。

スタックから始めましょう。

## スタック

**スタック**は**LIFO**（Last In, First Out：後入れ先出し）データ構造です。  
関数を呼び出すと、新しい**スタックフレーム**がスタックの上に追加されます。そのスタックフレームは関数の引数、ローカル変数、いくつかの「簿記」値を格納します。  
関数が戻ると、スタックフレームはスタックからポップされます[^stack-overflow]。

```text
+-----------------+
| frame for func1 |
+-----------------+
        |
        | func2 is 
        | called
        v
+-----------------+
| frame for func2 |
+-----------------+
| frame for func1 |
+-----------------+
        |
        | func2  
        | returns
        v
+-----------------+
| frame for func1 |
+-----------------+
```

操作的な観点から、スタックの割り当て/解放は**非常に高速**です。  
常にスタックの先頭からデータをプッシュしたりポップしたりするので、空きメモリを検索する必要がありません。
断片化についても心配する必要がありません：スタックは単一の連続したメモリブロックです。

### Rust

Rustはしばしばデータをスタックに割り当てます。  
関数に`u32`の入力引数がありますか？その32ビットはスタックにあります。
`i64`型のローカル変数を定義しますか？その64ビットはスタックにあります。
これらの整数のサイズはコンパイル時に知られているため、コンパイルされたプログラムはそれらのためにスタックにどれだけの領域を予約する必要があるかを知っているので、すべてうまく機能します。

### `std::mem::size_of`

[`std::mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html)関数を使用して型がスタックでどれだけの領域を取るかを確認できます。

例えば、`u8`の場合：

```rust
// この面白い見た目の構文（`::<u8>`）については後で説明します。
// 今のところは無視してください。
assert_eq!(std::mem::size_of::<u8>(), 1);
```

1は理にかなっています。`u8`は8ビット長、つまり1バイトだからです。

[^stack-overflow]: ネストした関数呼び出しがある場合、各関数は呼び出されたときにデータをスタックにプッシュしますが、最も内側の関数が戻るまでそれをポップしません。
ネストした関数呼び出しが多すぎると、スタック領域が不足する可能性があります—スタックは無限ではありません！
これを[**スタックオーバーフロー**](https://en.wikipedia.org/wiki/Stack_overflow)と呼びます。