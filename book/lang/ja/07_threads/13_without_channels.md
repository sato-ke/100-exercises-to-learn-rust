# デザインレビュー

私たちが歩んできた旅を振り返る時間を取りましょう。

## チャンネルシリアル化によるロックレス

マルチスレッドチケットストアの最初の実装では以下を使用しました：

- 共有状態を保持する単一の長時間実行スレッド（サーバー）
- 自分のスレッドからチャンネル経由でリクエストを送信する複数のクライアント。

サーバーが状態を変更する唯一の存在だったため、状態のロックは必要ありませんでした。「受信箱」チャンネルが
着信リクエストを自然に**シリアル化**したからです：サーバーはそれらを一つずつ処理しました。\
パッチ動作に関するこのアプローチの制限についてはすでに議論しましたが、
元の設計のパフォーマンスへの影響については議論していません：サーバーは一度に1つのリクエストのみを処理でき、
読み取りも含まれます。

## 細粒ロック

その後、各チケットが独自のロックによって保護され、
クライアントが独立してチケットを読み取るか原子的に変更するかを決定し、適切なロックを取得するより洗練された設計に移行しました。

この設計はより良い並列処理を可能にします（つまり、複数のクライアントが同時にチケットを読み取ることができます）が、
依然として根本的に**シリアル**です：サーバーはコマンドを一つずつ処理します。特に、クライアントに
ロックを一つずつ渡します。

チャンネルを完全に削除し、クライアントが`TicketStore`に直接アクセスし、
アクセスを同期するためにロックのみに依存することはできるでしょうか？

## チャンネルの削除

解決する必要がある2つの問題があります：

- スレッド間での`TicketStore`の共有
- ストアへのアクセスの同期

### スレッド間での`TicketStore`の共有

すべてのスレッドが同じ状態を参照することを望みます。そうでなければ、本当にマルチスレッドシステムではありません—
単に複数のシングルスレッドシステムを並行して実行しているだけです。\
スレッド間でロックを共有しようとしたときにこの問題に既に遭遇しました：`Arc`を使用できます。

### ストアへのアクセスの同期

チャンネルによって提供されるシリアル化のおかげで、まだロックレスである1つのやり取りがあります：
ストアからのチケットの挿入（または削除）。\
チャンネルを削除する場合、`TicketStore`自体へのアクセスを同期するために（別の）ロックを導入する必要があります。

`Mutex`を使用する場合、各チケットに追加の`RwLock`を使用することは意味がありません：`Mutex`が
すでにストア全体へのアクセスをシリアル化するため、とにかくチケットを並行して読み取ることはできません。\
代わりに`RwLock`を使用する場合、チケットを並行して読み取ることができます。チケットを��入入または
削除する間、すべての読み取りを一時停止する必要があります。

この道を進んで、どこに導くかを見てみましょう。