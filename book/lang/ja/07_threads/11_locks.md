# ロック、`Send`、`Arc`

先ほど実装したパッチ戦略には大きな欠点があります：競合状態があることです。\
2つのクライアントが同じチケットに対してほぼ同時にパッチを送信すると、サーバーはそれらを任意の順序で適用します。
パッチを最後にエンキューした人が、他のクライアントによって行われた変更を上書きします。

## バージョン番号

**バージョン番号**を使用してこれを修正することを試みることができます。\
各チケットは作成時にバージョン番号が割り当てられ、`0`に設定されます。
クライアントがパッチを送信するときはいつでも、
望ましい変更と一緒にチケットの現在のバージョン番号を含める必要があります。サーバーは、バージョン番号が格納されているものと一致する場合のみパッチを適用します。

上記のシナリオでは、最初のパッチによってバージョン番号がインクリメントされ、2番目のクライアントから送信されたものと一致しなくなるため、サーバーは2番目のパッチを拒否します。

このアプローチは分散システム（例：クライアントとサーバーがメモリを共有しない場合）でかなり一般的であり、
**楽観的並行性制御**として知られています。\
アイデアは、ほとんどの場合、競合が起こらないので、一般的なケースに最適化できるということです。
あなたは今やRustについて十分に知っているので、この戦略をボーナス演習として自分で実装できます。

## ロック

**ロック**を導入することで競合状態を修正することもできます。\
クライアントがチケットを更新したい場合、まずそれにロックを取得する必要があります。ロックがアクティブな間、
他のクライアントはチケットを変更できません。

Rustの標準ライブラリは2つの異なるロックプリミティブを提供しています：`Mutex<T>`と`RwLock<T>`。\
`Mutex<T>`から始めましょう。これは**mut**ual **ex**clusionの略で、最もシンプルな種類のロックです：
読み書きに関係なく、1つのスレッドのみがデータにアクセスすることを許可します。

`Mutex<T>`は保護するデータをラップし、したがってデータの型に対してジェネリックです。\
データに直接アクセスすることはできません：型システムは、`Mutex::lock`または
`Mutex::try_lock`を使用して最初にロックを取得することを強制します。前者はロックが取得されるまでブロックし、後者はロック
を取得できない場合、すぐにエラーで戻ります。\
両方のメソッドは、データを逆参照するガードオブジェクトを返し、変更できるようにします。ロックは
ガードがドロップされるときに解放されます。

```rust
use std::sync::Mutex;

// ミューテックスロックによって保護された整数
let lock = Mutex::new(0);

// ミューテックスのロックを取得
let mut guard = lock.lock().unwrap();

// ガードを通じてデータを変更、
// その`Deref`実装を活用
*guard += 1;

// `data`がスコープ外に出るとロックが解放されます
// これはガードを明示的にドロップすることで行うことができます
// またはガードがスコープ外に出るときに暗黙的に発生します
drop(guard)
```

## ロック粒度

`Mutex`は何をラップすべきでしょうか？\
最もシンプルなオプションは、`TicketStore`全体を単一の`Mutex`でラップすることです。
これは機能しますが、システムのパフォーマンスを大幅に制限します：チケットを並行して読むことはできません。
すべての読み取りはロックが解放されるのを待つ必要があるからです。
これは**粗粒ロック**として知られています。

各チケットが独自のロックによって保護される**細粒ロック**を使用する方が良いでしょう。
この方法では、同じチケットにアクセスしようとしていない限り、クライアントはチケットと並行して作業を続けることができます。

```rust
// 各チケットにロックがある新しい構造
struct TicketStore {
    tickets: BTreeMap<TicketId, Mutex<Ticket>>,
}
```

このアプローチはより効率的ですが、欠点があります：`TicketStore`がシステムのマルチスレッド
性質を**認識**する必要があります。今まで、`TicketStore`はスレッドの存在を幸福に無視してきました。\
とにかく進めましょう。

## 誰がロックを保持するか？

スキーム全体が機能するためには、ロックはチケットを変更したいクライアントに渡される必要があります。\
クライアントは直接チケットを変更し（`&mut Ticket`を持っているかのように）、完了したらロックを解放できます。

これは少し複雑です。\
`Mutex<Ticket>`をチャンネル経由で送信できません。`Mutex`は`Clone`ではなく、
`TicketStore`から移動できないからです。代わりに`MutexGuard`を送信できるでしょうか？

小さな例でアイデアをテストしてみましょう：

```rust
use std::thread::spawn;
use std::sync::Mutex;
use std::sync::mpsc::sync_channel;

fn main() {
    let lock = Mutex::new(0);
    let (sender, receiver) = sync_channel(1);
    let guard = lock.lock().unwrap();

    spawn(move || {
        receiver.recv().unwrap();
    });

    // ガードをチャンネル経由で
    // 別のスレッドに送信しようとします
    sender.send(guard);
}
```

コンパイラはこのコードを喜んでいません：

```text
error[E0277]: `MutexGuard<'_, i32>` cannot be sent between 
              threads safely
   --> src/main.rs:10:7
    |
10  |   spawn(move || {
    |  _-----_^
    | | |
    | | required by a bound introduced by this call
11  | |     receiver.recv().unwrap();
12  | | });
    | |_^ `MutexGuard<'_, i32>` cannot be sent between threads safely
    |
    = help: the trait `Send` is not implemented for 
            `MutexGuard<'_, i32>`, which is required by 
            `{closure@src/main.rs:10:7: 10:14}: Send`
    = note: required for `Receiver<MutexGuard<'_, i32>>` 
            to implement `Send`
note: required because it's used within this closure
```

`MutexGuard<'_, i32>`は`Send`ではありません：これは何を意味するのでしょうか？

## `Send`

`Send`は、型が一つのスレッドから別のスレッドに安全に転送できることを示すマーカートレイトです。\
`Send`は`Sized`と同様に自動トレイトでもあります。コンパイラによって、
その定義に基づいて型に対して自動的に実装（または実装されない）されます。\
型に対して`Send`を手動で実装することもできますが、コンパイラが自動的に検証できない理由で
型が実際にスレッド間で送信しても安全であることを保証する必要があるため、`unsafe`が必要です。

### チャンネル要件

`Sender<T>`、`SyncSender<T>`、`Receiver<T>`は、`T`が`Send`である場合のみ`Send`です。\
これは、それらがスレッド間で値を送信するために使用され、値自体が`Send`でない場合、
スレッド間で送信するのは安全ではないからです。

### `MutexGuard`

`MutexGuard`は`Send`ではありません。`Mutex`がロックを実装するために使用する
基礎となるオペレーティングシステムプリミティブが（一部のプラットフォームで）、
ロックを取得したのと同じスレッドによってロックが解放される必要があるからです。\
`MutexGuard`を別のスレッドに送信すると、ロックが異なるスレッドによって解放され、
未定義動作につながります。

## 私たちの課題

まとめると：

- `MutexGuard`をチャンネル経由で送信できません。そのため、サーバー側でロックしてから
  クライアント側でチケットを変更することはできません。
- `Mutex`は、保護するデータが`Send`である限り`Send`であるため、チャンネル経由で送信できます。これは
  `Ticket`の場合です。
  同時に、`TicketStore`から`Mutex`を移動することも、クローンすることもできません。

この難問をどのように解決できるでしょうか？\
問題を異なる角度から見る必要があります。
`Mutex`をロックするために、所有値は必要ありません。`Mutex`は内部可変性を使用するため、共有参照で十分です：

```rust
impl<T> Mutex<T> {
    // `self`ではなく`&self`！
    pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {
        // 実装の詳細
    }
}
```

したがって、クライアントに共有参照を送信するだけで十分です。\
ただし、参照は`'static`である必要があり、それは該当しないため、直接行うことはできません。
ある意味、「所有された共有参照」が必要です。Rustには、この要件に適合する型があることがわかります：`Arc`。

## `Arc`の救助

`Arc`は**アトミック参照カウント**の略です。\
`Arc`は値をラップし、値への参照がいくつ存在するかを追跡します。
最後の参照がドロップされると、値は解放されます。\
`Arc`でラップされた値は不変です：共有参照のみを取得できます。

```rust
use std::sync::Arc;

let data: Arc<u32> = Arc::new(0);
let data_clone = Arc::clone(&data);

// `Arc<T>`は`Deref<T>`を実装するため、
// deref強制を使用して`&Arc<T>`を`&T`に変換できます
let data_ref: &u32 = &data;
```

デジャヴの瞬間を感じているなら、それは正しいです：`Arc`は、内部可変性について話すときに紹介した参照カウントポインタ`Rc`によく似ています。違いはスレッド安全性です：`Rc`は`Send`ではありませんが、`Arc`は`Send`です。
これは参照カウントが実装される方法に帰結します：`Rc`は「通常の」整数を使用し、`Arc`は
スレッド間で安全に共有および変更できる**アトミック**整数を使用します。

## `Arc<Mutex<T>>`

`Arc`と`Mutex`を組み合わせると、最終的に次のような型が得られます：

- スレッド間で送信できる。なぜなら：
  - `Arc`は`T`が`Send`であれば`Send`であり、
  - `Mutex`は`T`が`Send`であれば`Send`です。
  - `T`は`Ticket`であり、これは`Send`です。
- クローンできる。`Arc`は`T`が何であっても`Clone`だからです。
  `Arc`をクローンすると参照カウントがインクリメントされ、データはコピーされません。
- ラップするデータを変更するために使用できる。`Arc`は
  `Mutex<T>`への共有参照を取得でき、それをロック取得に使用できるからです。

チケットストア用のロック戦略を実装するために必要なすべてのピースがあります。

## 参考文献

- このコースではアトミック操作の詳細をカバーしませんが、より多くの情報を
  [`std`ドキュメント](https://doc.rust-lang.org/std/sync/atomic/index.html)および
  [「Rust atomics and locks」書籍](https://marabos.nl/atomics/)で見つけることができます。