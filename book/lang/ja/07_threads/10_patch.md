# 更新操作

これまでのところ、挿入と取得操作のみを実装してきました。\
システムを拡張して更新操作を提供する方法を見てみましょう。

## レガシー更新

システムの非スレッド版では、更新は非常に簡単でした：`TicketStore`は
呼び出し元がチケットへの可変参照を取得し、それを変更できる`get_mut`メソッドを公開していました。

## マルチスレッド更新

現在のマルチスレッド版では、同じ戦略は機能しません。借用チェッカーが
私たちを止めるでしょう：`&mut Ticket`が`'static`ライフタイムを満たさないため、`SyncSender<&mut Ticket>`は`'static`ではなく、
`std::thread::spawn`に渡されるクロージャによってキャプチャできません。

この制限を回避するいくつかの方法があります。次の演習でそれらのいくつかを探ります。

### パッチ適用

`&mut Ticket`をチャンネル経由で送信できないため、クライアント側で変更できません。\
サーバー側で変更できるでしょうか？

変更する必要があることをサーバーに伝えれば可能です。言い換えると、サーバーに**パッチ**を送信する場合：

```rust
struct TicketPatch {
    id: TicketId,
    title: Option<TicketTitle>,
    description: Option<TicketDescription>,
    status: Option<TicketStatus>,
}
```

`id`フィールドは必須です。更新する必要があるチケットを識別するために必要だからです。\
他のすべてのフィールドはオプションです：

- フィールドが`None`の場合、そのフィールドは変更すべきでないことを意味します。
- フィールドが`Some(value)`の場合、そのフィールドを`value`に変更すべきことを意味します。