# 内部可変性

`Sender`の`send`のシグネチャについて少し考えてみましょう：

```rust
impl<T> Sender<T> {
    pub fn send(&self, t: T) -> Result<(), SendError<T>> {
        // [...]
    }
}
```

`send`は引数として`&self`を取ります。\
しかし、これは明らかに変更を引き起こしています：チャンネルに新しいメッセージを追加しています。
さらに興味深いのは、`Sender`がクローン可能であることです：複数の`Sender`インスタンスが
異なるスレッドから**同時に**チャンネル状態を変更しようとする可能性があります。

これが、このクライアント・サーバー・アーキテクチャを構築するために使用している重要なプロパティです。しかし、なぜ機能するのでしょうか？
Rustの借用に関するルールに違反していませんか？_不変_参照を介してどのように変更を実行しているのでしょうか？

## 不変ではなく共有参照

借用チェッカーを導入したとき、Rustで持てる2種類の参照に名前を付けました：

- 不変参照（`&T`）
- 可変参照（`&mut T`）

次のように名前を付ける方がより正確だったでしょう：

- 共有参照（`&T`）
- 排他参照（`&mut T`）

不変/可変は、大多数のケースで機能するメンタルモデルであり、Rustを始めるには素晴らしいものです。しかし、今見たように、それが全体の話ではありません：`&T`は実際には、それが
指すデータが不変であることを保証しません。\
しかし、心配しないでください：Rustはまだその約束を守っています。
用語が最初に見えるほど微妙ではないだけです。

## `UnsafeCell`

型が共有参照を通じてデータを変更することを許可するときはいつでも、**内部可変性**を扱っています。

デフォルトでは、Rustコンパイラは共有参照が不変であると仮定します。その仮定に基づいて**コードを最適化**します。\
コンパイラは操作を並べ替え、値をキャッシュし、コードを高速化するためのあらゆる種類の魔法を行うことができます。

`UnsafeCell`でデータをラップすることで、コンパイラに「いいえ、この共有参照は実際には可変です」と伝えることができます。\
内部可変性を許可する型を見るたびに、`UnsafeCell`が関与していることを確信できます。
直接的または間接的に。\
`UnsafeCell`、生ポインタ、`unsafe`コードを使用して、共有参照を通じてデータを変更できます。

ただし、明確にしておきましょう：`UnsafeCell`は借用チェッカーを無視できる魔法の杖ではありません！\
`unsafe`コードは、借用とエイリアシングに関するRustのルールの対象です。
これは、Rustの型システムで直接表現できない安全性を保証する**安全な抽象化**を構築するために活用できる（高度な）ツールです。`unsafe`キーワードを使用するときはいつでも、コンパイラに次のように伝えています：
「何をしているかわかっています。あなたの不変量に違反しません。信頼してください。」

`unsafe`関数を呼び出すたびに、その**安全性前提条件**を説明するドキュメントがあります：
その`unsafe`ブロックを実行するのが安全な状況。`UnsafeCell`のものは
[`std`のドキュメント](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html)で見つけることができます。

このコースでは`UnsafeCell`を直接使用することも、`unsafe`コードを書くこともありません。
しかし、それがそこにある理由、存在する理由、および
Rustで毎日使用する型とどのように関係するかを知ることは重要です。

## 主要な例

内部可変性を活用するいくつかの重要な`std`型を見てみましょう。\
これらは、特に使用するライブラリの内部を覗く場合、Rustコードでかなり頻繁に遭遇する型です。

### 参照カウント

`Rc`は参照カウントポインタです。\
値をラップし、値への参照がいくつ存在するかを追跡します。
最後の参照がドロップされると、値は解放されます。\
`Rc`でラップされた値は不変です：共有参照しか取得できません。

```rust
use std::rc::Rc;

let a: Rc<String> = Rc::new("My string".to_string());
// 文字列データへの参照は1つだけ存在します。
assert_eq!(Rc::strong_count(&a), 1);

// `clone`を呼び出すとき、文字列データはコピーされません！
// 代わりに、`Rc`の参照カウントがインクリメントされます。
let b = Rc::clone(&a);
assert_eq!(Rc::strong_count(&a), 2);
assert_eq!(Rc::strong_count(&b), 2);
// ^ `a`と`b`の両方が同じ文字列データを指し、
//   同じ参照カウンタを共有します。
```

`Rc`は内部的に`UnsafeCell`を使用して、共有参照が参照カウントをインクリメントおよびデクリメントできるようにします。

### `RefCell`

`RefCell`は、Rustで内部可変性の最も一般的な例の1つです。
`RefCell`自体への不変参照しか持っていなくても、
`RefCell`でラップされた値を変更できます。

これは**ランタイム借用チェック**を介して行われます。
`RefCell`は、含まれる値への参照の数（と型）をランタイムで追跡します。
すでに不変借用されている間に値を可変借用しようとすると、
プログラムはパニックし、Rustの借用ルールが常に強制されることを保証します。

```rust
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // 不変借用
let z = x.borrow_mut(); // パニック！アクティブな不変借用があります。
```