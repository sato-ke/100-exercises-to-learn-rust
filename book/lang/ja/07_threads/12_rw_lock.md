# リーダーとライター

新しい`TicketStore`は機能しますが、読み取りパフォーマンスはそれほど良くありません：一度に特定の
チケットを読み取れるクライアントは1つだけです。`Mutex<T>`がリーダーとライターを区別しないからです。

異なるロックプリミティブ`RwLock<T>`を使用することで問題を解決できます。\
`RwLock<T>`は**読み書きロック**の略です。**複数のリーダー**が同時にデータにアクセスすることを許可しますが、
一度に1つのライターのみです。

`RwLock<T>`にはロックを取得する2つのメソッドがあります：`read`と`write`。\
`read`はデータを読み取れるガードを返し、`write`はデータを変更できるガードを返します。

```rust
use std::sync::RwLock;

// 読み書きロックによって保護された整数
let lock = RwLock::new(0);

// RwLockで読み取りロックを取得
let guard1 = lock.read().unwrap();

// 最初のロックがまだアクティブな間に
// **二番目の**読み取りロックを取得
let guard2 = lock.read().unwrap();
```

## トレードオフ

表面的には、`RwLock<T>`は当然の選択のように見えます：`Mutex<T>`の機能のスーパーセットを提供します。
代わりに`RwLock<T>`を使用できるなら、なぜ`Mutex<T>`を使用するのでしょうか？

2つの主要な理由があります：

- `RwLock<T>`のロックは`Mutex<T>`のロックよりも高価です。\
  これは、`RwLock<T>`がアクティブなリーダーとライターの数を追跡する必要があるのに対し、`Mutex<T>`は
  ロックが保持されているかどうかのみを追跡する必要があるからです。
  このパフォーマンスオーバーヘッドは、ライターよりもリーダーが多い場合は問題になりませんが、ワークロードが
  書き込み重要な場合は`Mutex<T>`の方が良い選択かもしれません。
- `RwLock<T>`は**ライター飢餓**を引き起こす可能性があります。\
  ロックを取得しようと待機しているリーダーが常にいる場合、ライターは実行する機会を得られない可能性があります。
  `RwLock<T>`は、リーダーとライターがロックへのアクセスを許可される順序について保証を提供しません。
  これは基礎となるOSによって実装されるポリシーに依存し、ライターに対して公平でない可能性があります。

私たちの場合、ワークロードが読み取り重要（ほとんどのクライアントがチケットを変更するのではなく読み取るため）であることが期待できるので、
`RwLock<T>`は良い選択です。