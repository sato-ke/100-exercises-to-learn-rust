# チャンネル

これまでのスポーンされたスレッドはすべて、かなり短命でした。\
入力を取得し、計算を実行し、結果を返し、シャットダウンします。

チケット管理システムでは、異なることをしたいと思います：
クライアント・サーバー・アーキテクチャです。

**1つの長時間実行されるサーバースレッド**があり、
状態、つまり格納されたチケットを管理する責任があります。

次に、**複数のクライアントスレッド**があります。\
各クライアントは、**コマンド**と**クエリ**を
ステートフルスレッドに送信して、その状態を変更（例：新しいチケットを追加）
または情報を取得（例：チケットのステータスを取得）できます。\
クライアントスレッドは並行して実行されます。

## 通信

これまでのところ、非常に限定的な親子通信しかありませんでした：

- スポーンされたスレッドは親コンテキストからデータを借用/消費した
- スポーンされたスレッドはジョインされたときに親にデータを返した

これはクライアント・サーバー設計には十分ではありません。\
クライアントは、サーバースレッドが起動された_後_に、
サーバースレッドとデータを送受信できる必要があります。

**チャンネル**を使用して問題を解決できます。

## チャンネル

Rustの標準ライブラリは、`std::sync::mpsc`モジュールで
**マルチプロデューサー、シングルコンシューマー**（mpsc）チャンネルを提供します。\
チャンネルには2つのフレーバーがあります：バウンドとアンバウンド。今はアンバウンド
版に固執しますが、長所と短所については後で説明します。

チャンネルの作成は次のようになります：

```rust
use std::sync::mpsc::channel;

let (sender, receiver) = channel();
```

センダーとレシーバーを取得します。\
センダーで`send`を呼び出してデータをチャンネルにプッシュします。
レシーバーで`recv`を呼び出してチャンネルからデータをプルします。

### 複数のセンダー

`Sender`はクローン可能です：複数のセンダーを作成でき（例：各
クライアントスレッドに1つずつ）、それらはすべて同じチャンネルにデータをプッシュします。

一方、`Receiver`はクローン可能ではありません：
特定のチャンネルに対してレシーバーは1つしか存在できません。

これが**mpsc**（マルチプロデューサー・シングルコンシューマー）が意味することです！

### メッセージタイプ

`Sender`と`Receiver`の両方は型パラメータ`T`に対してジェネリックです。\
これは、チャンネルで移動できる_メッセージ_の型です。

`u64`、構造体、列挙型などがあります。

### エラー

`send`と`recv`の両方が失敗する可能性があります。\
`send`は、レシーバーがドロップされた場合にエラーを返します。
`recv`は、すべてのセンダーがドロップされ、チャンネルが空の場合にエラーを返します。

言い換えると、`send`と`recv`は、チャンネルが事実上閉じられたときにエラーになります。