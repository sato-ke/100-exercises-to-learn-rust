# データリーク

スポーンされたスレッドに参照を渡すことに関する主な懸念は、use-after-freeバグです：
すでに解放/解放されたメモリ領域へのポインタを使用してデータにアクセスすることです。\
ヒープ割り当てデータを扱っている場合、そのメモリを決して回収しないとRustに伝えることで問題を回避できます：**メモリリーク**を意図的に選択するのです。

これは、例えば、Rustの標準ライブラリの`Box::leak`メソッドを使用して行うことができます：

```rust
// `u32`をヒープに割り当て、`Box`でラップします。
let x = Box::new(41u32);
// `Box::leak`を使用して、そのヒープ割り当てを決して解放しないとRustに伝えます。
// これにより、'static参照を取得できます。
let static_ref: &'static mut u32 = Box::leak(x);
```

## データリークはプロセススコープです

データリークは危険です：メモリをリークし続けると、最終的にメモリが不足し、
メモリ不足エラーでクラッシュします。

```rust
// これをしばらく実行していると、
// 最終的に利用可能なメモリをすべて使用します。
fn oom_trigger() {
    loop {
        let v: Vec<usize> = Vec::with_capacity(1024);
        v.leak();
    }
}
```

同時に、`leak`メソッドでリークされたメモリは本当に忘れられるわけではありません。\
オペレーティングシステムは各メモリ領域を、それを担当するプロセスにマップできます。
プロセスが終了すると、オペレーティングシステムはそのメモリを回収します。

これを念頭に置いて、以下の場合にメモリをリークすることは問題ありません：

- リークする必要があるメモリの量が制限されている/事前に知られている、または
- プロセスが短命で、終了する前に
  利用可能なメモリをすべて使い果たすことはないと確信している

「OSに任せる」は、ユースケースが許す場合、
完全に有効なメモリ管理戦略です。