# バウンドvsアンバウンドチャンネル

これまでアンバウンドチャンネルを使用してきました。\
好きなだけメッセージを送信でき、チャンネルはそれらを収容するために成長します。
マルチプロデューサー・シングルコンシューマーシナリオでは、これは問題になる可能性があります：プロデューサーが
コンシューマーが処理できるよりも速い速度でメッセージをエンキューすると、チャンネルは
成長し続け、利用可能なメモリをすべて消費する可能性があります。

本番システムでアンバウンドチャンネルを**決して**使用しないことをお勧めします。\
**バウンドチャンネル**を使用して、エンキューできるメッセージ数に上限を設けるべきです。

## バウンドチャンネル

バウンドチャンネルには固定容量があります。\
0より大きい容量で`sync_channel`を呼び出すことで作成できます：

```rust
use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);
```

`receiver`は以前と同じ型、`Receiver<T>`です。\
一方、`sender`は`SyncSender<T>`のインスタンスです。

### メッセージ送信

`SyncSender`を通じてメッセージを送信する2つの異なるメソッドがあります：

- `send`：チャンネルに空きがある場合、メッセージをエンキューして`Ok(())`を返します。\
  チャンネルが満杯の場合、ブロックして空きができるまで待機します。
- `try_send`：チャンネルに空きがある場合、メッセージをエンキューして`Ok(())`を返します。\
  チャンネルが満杯の場合、`Err(TrySendError::Full(value))`を返します。ここで`value`は送信できなかったメッセージです。

ユースケースに応じて、どちらか一方を使用したい場合があります。

### バックプレッシャー

バウンドチャンネルを使用する主な利点は、**バックプレッシャー**の形式を提供することです。\
コンシューマーが追いつけない場合、プロデューサーに速度を落とすことを強制します。
バックプレッシャーはシステム全体に伝播し、アーキテクチャ全体に影響を与え、
エンドユーザーがリクエストでシステムを圧倒することを防ぐ可能性があります。