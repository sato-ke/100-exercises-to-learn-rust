# まとめ

Rustの非同期モデルは非常に強力ですが、追加の複雑さをもたらします。
ツールを知るのに時間をかけてください：`tokio`のドキュメントを深く掘り下げ、
そのプリミティブに慣れ親しんで、最大限に活用してください。

また、Rustの非同期ストーリーを合理化し「完成」させるために、言語と`std`レベルで
進行中の作業があることも覚えておいてください。これらの欠けている部分のために、
日常業務でいくつかの粗い部分を経験するかもしれません。

ほとんど痛みのない非同期体験のためのいくつかの推奨事項：

- **ランタイムを選んでそれに固執する。**\
  一部のプリミティブ（例：タイマー、I/O）はランタイム間で移植可能ではありません。
  ランタイムを混ぜようとすると、痛みを引き起こす可能性があります。
  ランタイムに依存しないコードを書こうとすると、コードベースの複雑さが
  大幅に増加する可能性があります。できれば避けてください。
- **まだ安定した`Stream`/`AsyncIterator`インターフェースはありません。**\
  `AsyncIterator`は、概念的には、新しいアイテムを非同期に生成するイテレータです。
  進行中の設計作業がありますが、（まだ）コンセンサスはありません。
  `tokio`を使用している場合は、[`tokio_stream`](https://docs.rs/tokio-stream/latest/tokio_stream/)
  を頼りのインターフェースとして参照してください。
- **バッファリングに注意してください。**\
  これはしばしば微妙なバグの原因です。詳細については
  [「Barbara battles buffered streams」](https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_battles_buffered_streams.html)
  を確認してください。
- **非同期タスクのスコープ付きスレッドに相当するものはありません。**\
  詳細については[「The scoped task trilemma」](https://without.boats/blog/the-scoped-task-trilemma/)
  を確認してください。

これらの注意事項に怖がらないでください：非同期Rustは、基盤となるサービスを
動かすために_大規模_（例：AWS、Meta）で効果的に使用されています。\
Rustでネットワークアプリケーションを構築する予定がある場合は、
それをマスターする必要があります。