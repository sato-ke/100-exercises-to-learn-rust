# 非同期対応プリミティブ

`tokio`のドキュメントを見ると、標準ライブラリのものを「ミラー」するが、非同期のひねりを
加えた多くの型を提供していることに気づくでしょう：ロック、チャネル、タイマーなど。

非同期コンテキストで作業する場合、同期版の対応物よりもこれらの非同期代替を優先すべきです。

なぜかを理解するために、前の章で探求した相互排他ロックである`Mutex`を見てみましょう。

## ケーススタディ：`Mutex`

簡単な例を見てみましょう：

```rust
use std::sync::{Arc, Mutex};

async fn run(m: Arc<Mutex<Vec<u64>>>) {
    let guard = m.lock().unwrap();
    http_call(&guard).await;
    println!("Sent {:?} to the server", &guard);
    // `guard`はここでドロップされる
}

/// `v`をHTTP呼び出しのボディとして使用する
async fn http_call(v: &[u64]) {
  // [...]
}
```

### `std::sync::MutexGuard`とイールドポイント

このコードはコンパイルされますが、危険です。

非同期コンテキストで`std`の`Mutex`に対するロックの取得を試みています。
その後、イールドポイント（`http_call`での`.await`）をまたいで、
結果の`MutexGuard`を保持しています。

シングルスレッドランタイムで`run`を実行する2つのタスクが並行して存在すると
想像してみましょう。以下のスケジューリングイベントのシーケンスが観察されます：

```text
     タスクA          タスクB
        | 
  ロックを取得
ランタイムにイールド
        | 
        +--------------+
                       |
             ロックの取得を試みる
```

デッドロックが発生しています。タスクBはロックを取得することができません。
なぜなら、ロックは現在タスクAによって保持されており、タスクAはロックを解放する前に
ランタイムにイールドしており、ランタイムがタスクBをプリエンプトできないため、
再度スケジュールされません。

### `tokio::sync::Mutex`

`tokio::sync::Mutex`に切り替えることで問題を解決できます：

```rust
use std::sync::Arc;
use tokio::sync::Mutex;

async fn run(m: Arc<Mutex<Vec<u64>>>) {
    let guard = m.lock().await;
    http_call(&guard).await;
    println!("Sent {:?} to the server", &guard);
    // `guard`はここでドロップされる
}
```

ロックの取得は今や非同期操作となり、進行できない場合はランタイムに戻ります。\
前のシナリオに戻ると、以下のことが起こります：

```text
       タスクA          タスクB
          | 
  ロックを取得
  `http_call`を開始
  ランタイムにイールド
          | 
          +--------------+
                         |
             ロックの取得を試みる
              ロックを取得できない
                ランタイムにイールド
                         |
          +--------------+
          |
`http_call`が完了      
  ロックを解放
  ランタイムにイールド
          |
          +--------------+
                         |
                ロックを取得
                      [...]
```

すべて良好です！

### マルチスレッドでも救われない

前の例では実行コンテキストとしてシングルスレッドランタイムを使用しましたが、
マルチスレッドランタイムを使用しても同じリスクが存在します。\
唯一の違いは、デッドロックを作成するために必要な並行タスクの数です：
シングルスレッドランタイムでは2つで十分です。マルチスレッドランタイムでは、
`N+1`個のタスクが必要になります。ここで`N`はランタイムスレッドの数です。

### 欠点

非同期対応の`Mutex`を持つことには、パフォーマンスペナルティが伴います。\
ロックが大きな競合状態にない_かつ_イールドポイントをまたいで保持しないよう
注意深く扱うことに自信がある場合、非同期コンテキストでも`std::sync::Mutex`を
使用できます。

しかし、パフォーマンスの利点と、発生するライブネスリスクを比較検討してください。

## その他のプリミティブ

`Mutex`を例として使用しましたが、同じことが`RwLock`、セマフォなどにも当てはまります。\
非同期コンテキストで作業する場合は、問題のリスクを最小限に抑えるために、
非同期対応バージョンを優先してください。