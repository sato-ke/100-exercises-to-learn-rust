# 非同期関数

これまで書いてきた関数やメソッドはすべて即座に実行されるものでした。\
呼び出すまでは何も起こりません。しかし、一度呼び出すと完了まで実行されます：
**すべて**の作業を行い、その後出力を返します。

時にはこれが望ましくない場合があります。\
例えば、HTTPサーバーを書いている場合、多くの**待機**が発生する可能性があります：
リクエストボディの到着を待つ、データベースの応答を待つ、下流サービスの返信を待つなど。

待っている間に他のことができたらどうでしょうか？\
計算の途中で諦めることができたらどうでしょうか？\
現在のタスクよりも別のタスクを優先することができたらどうでしょうか？

そこで**非同期関数**の出番です。

## `async fn`

非同期関数を定義するには`async`キーワードを使用します：

```rust
use tokio::net::TcpListener;

// これは非同期関数です
async fn bind_random() -> TcpListener {
    // [...]
}
```

通常の関数のように`bind_random`を呼び出すと何が起こるでしょうか？

```rust
fn run() {
    // `bind_random`を呼び出す
    let listener = bind_random();
    // それで？
}
```

何も起こりません！\
Rustは`bind_random`を呼び出してもその実行を開始しません。
バックグラウンドタスクとしても実行されません（他の言語の経験から期待するかもしれませんが）。
Rustの非同期関数は**遅延評価**されます：明示的に要求するまで作業を行いません。
Rustの用語では、`bind_random`は**フューチャー**を返すと言います。
これは後で完了する可能性のある計算を表す型です。
`Future`トレイトを実装しているため、フューチャーと呼ばれます。
このインターフェースについては、この章の後半で詳しく調べます。

## `.await`

非同期関数に作業をさせる最も一般的な方法は、`.await`キーワードを使用することです：

```rust
use tokio::net::TcpListener;

async fn bind_random() -> TcpListener {
    // [...]
}

async fn run() {
    // `bind_random`を呼び出し、完了まで待つ
    let listener = bind_random().await;
    // `listener`が準備完了
}
```

`.await`は非同期関数が完了するまで（例：上記の例では`TcpListener`が作成されるまで）
呼び出し元に制御を返しません。

## ランタイム

困惑しているなら、それは正しい反応です！\
非同期関数の利点は**すべて**の作業を一度に行わないことだと言いました。
その後、非同期関数が完了するまで戻らない`.await`を紹介しました。
解決しようとしていた問題を再導入しただけではないでしょうか？意味は何でしょうか？

そうではありません！`.await`を呼び出すと、舞台裏で多くのことが起こります！\
**非同期ランタイム**（**非同期エグゼキュータ**とも呼ばれる）に制御を渡しています。
エグゼキュータは魔法が起こる場所です：進行中のすべての非同期**タスク**を管理する責任があります。
特に、2つの異なる目標のバランスを取ります：

- **進行**：タスクが可能な限り進行することを確保します。
- **効率**：タスクが何かを待っている場合、その間に別のタスクが実行できるように、
  利用可能なリソースを完全に活用しようとします。

### デフォルトランタイムなし

Rustは非同期プログラミングへのアプローチにおいてかなりユニークです：
デフォルトのランタイムがありません。標準ライブラリには付属していません。
自分で用意する必要があります！

ほとんどの場合、エコシステムで利用可能なオプションの1つを選択します。
一部のランタイムは広く適用できるように設計されており、ほとんどのアプリケーションに適した選択肢です。
`tokio`と`async-std`はこのカテゴリに属します。
他のランタイムは特定のユースケースに最適化されています。例：組み込みシステム向けの`embassy`。

このコース全体を通して、Rustの汎用非同期プログラミングで最も人気のあるランタイムである`tokio`を使用します。

### `#[tokio::main]`

実行可能ファイルのエントリポイントである`main`関数は、同期関数でなければなりません。
そこで選択した非同期ランタイムをセットアップして起動することになっています。

ほとんどのランタイムは、これを簡単にするマクロを提供しています。`tokio`の場合は`tokio::main`です：

```rust
#[tokio::main]
async fn main() {
    // 非同期コードをここに書く
}
```

これは次のように展開されます：

```rust
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(
        // 非同期関数をここに書く
        // [...]
    );
}
```

### `#[tokio::test]`

テストについても同様です：同期関数でなければなりません。\
各テスト関数は独自のスレッドで実行され、テストで非同期コードを実行する必要がある場合は、
非同期ランタイムをセットアップして起動する責任があります。\
`tokio`はこれを簡単にする`#[tokio::test]`マクロを提供しています：

```rust
#[tokio::test]
async fn my_test() {
    // 非同期テストコードをここに書く
}
```