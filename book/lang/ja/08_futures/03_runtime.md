# ランタイムアーキテクチャ

これまで、非同期ランタイムを抽象的な概念として話してきました。
実装方法についてもう少し深く掘り下げてみましょう。すぐにわかるように、
これは私たちのコードに影響を与えます。

## フレーバー

`tokio`は2つの異なるランタイム_フレーバー_を提供しています。

`tokio::runtime::Builder`を使用してランタイムを設定できます：

- `Builder::new_multi_thread`は**マルチスレッド`tokio`ランタイム**を提供します
- `Builder::new_current_thread`は代わりに実行に**現在のスレッド**を使用します

`#[tokio::main]`はデフォルトでマルチスレッドランタイムを返し、
`#[tokio::test]`はデフォルトで現在のスレッドランタイムを使用します。

### 現在のスレッドランタイム

現在のスレッドランタイムは、その名前が示すように、タスクのスケジューリングと実行に
起動されたOSスレッドのみを使用します。\
現在のスレッドランタイムを使用する場合、**並行性**はありますが**並列性**はありません：
非同期タスクはインターリーブされますが、任意の時点で実行されるタスクは常に最大1つです。

### マルチスレッドランタイム

マルチスレッドランタイムを使用する場合、任意の時点で最大`N`個のタスクが
_並列に_実行される可能性があります。ここで`N`はランタイムが使用するスレッド数です。
デフォルトでは、`N`は利用可能なCPUコア数と一致します。

さらに：`tokio`は**ワークスティーリング**を実行します。\
スレッドがアイドル状態の場合、待機しません：グローバルキューから、または他のスレッドの
ローカルキューから盗むことで、実行準備ができた新しいタスクを見つけようとします。\
ワークスティーリングは、特にアプリケーションがスレッド間で完全にバランスが取れていない
ワークロードを扱っている場合、テイルレイテンシーに大きなパフォーマンス上の利点をもたらす可能性があります。

## 含意

`tokio::spawn`はフレーバーに依存しません：マルチスレッドまたは現在のスレッドランタイムで
実行していても動作します。欠点は、シグネチャが最悪のケース（つまりマルチスレッド）を
想定し、それに応じて制約されていることです：

```rust
pub fn spawn<F>(future: F) -> JoinHandle<F::Output>
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{ /* */ }
```

今は`Future`トレイトを無視して、残りに焦点を当てましょう。\
`spawn`はすべての入力が`Send`であり、`'static`ライフタイムを持つことを要求しています。

`'static`制約は、`std::thread::spawn`の`'static`制約と同じ理由に従います：
スポーンされたタスクは、スポーンされたコンテキストよりも長く生きる可能性があるため、
スポーン元のコンテキストが破棄された後に割り当て解除される可能性のあるローカルデータに
依存してはいけません。

```rust
fn spawner() {
    let v = vec![1, 2, 3];
    // これは動作しません。`&v`が
    // 十分に長く生きないからです。
    tokio::spawn(async { 
        for x in &v {
            println!("{x}")
        }
    })
}
```

一方、`Send`は`tokio`のワークスティーリング戦略の直接的な結果です：
スレッド`A`でスポーンされたタスクは、アイドル状態の場合はスレッド`B`に移動される
可能性があるため、スレッドの境界を越えているため`Send`境界が必要です。

```rust
fn spawner(input: Rc<u64>) {
    // これも動作しません。
    // `Rc`は`Send`ではないからです。
    tokio::spawn(async move {
        println!("{}", input);
    })
}
```