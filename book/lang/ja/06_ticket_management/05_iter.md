# `.iter()`

`IntoIterator`は`self`を**消費**してイテレータを作成します。

これには利点があります：イテレータから**所有された**値が得られます。
例：`Vec<Ticket>`で`.into_iter()`を呼び出すと、`Ticket`値を返すイテレータが得られます。

これは同時に欠点でもあります：`.into_iter()`を呼び出した後、元のコレクションを使用できなくなります。
多くの場合、コレクションを消費せずに反復したいことがあり、代わりに値への**参照**を見たいのです。
`Vec<Ticket>`の場合、`&Ticket`値を反復したいでしょう。

ほとんどのコレクションは、コレクションの要素への参照上のイテレータを返す`.iter()`と呼ばれるメソッドを公開しています。
例：

```rust
let numbers: Vec<u32> = vec![1, 2];
// ここで`n`は`&u32`型です
for n in numbers.iter() {
    // [...]
}
```

このパターンは、**コレクションへの参照**に対して`IntoIterator`を実装することで簡略化できます。
上記の例では、それは`&Vec<Ticket>`になります。\
標準ライブラリはこれを行っているため、以下のコードが動作します：

```rust
let numbers: Vec<u32> = vec![1, 2];
// ここで`n`は`&u32`型です
// 明示的に`.iter()`を呼び出す必要がありませんでした
// `for`ループで`&numbers`を使用するだけで十分でした
for n in &numbers {
    // [...]
}
```

両方のオプションを提供するのが慣用的です：

- コレクションへの参照に対する`IntoIterator`の実装。
- コレクションの要素への参照上のイテレータを返す`.iter()`メソッド。

前者は`for`ループで便利で、後者はより明示的で他のコンテキストで使用できます。