# `impl Trait`

`TicketStore::to_dos`は`Vec<&Ticket>`を返します。\
このシグネチャは、`to_dos`が呼び出されるたびに新しいヒープ割り当てを導入しますが、これは呼び出し元が結果で何をする必要があるかによっては不要な場合があります。
`to_dos`が`Vec`の代わりにイテレータを返し、呼び出し元が結果を`Vec`に収集するか単に反復するかを決定できるようにする方が良いでしょう。

しかし、それは難しいです！
以下のように実装された`to_dos`の戻り値の型は何でしょうか？

```rust
impl TicketStore {
    pub fn to_dos(&self) -> ??? {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
```

## 名前を付けられない型

`filter`メソッドは`std::iter::Filter`のインスタンスを返します。これは以下の定義を持ちます：

```rust
pub struct Filter<I, P> { /* フィールドは省略 */ }
```

ここで`I`はフィルタされるイテレータの型、`P`は要素をフィルタするために使用される述語です。\
この場合、`I`は`std::slice::Iter<'_, Ticket>`であることはわかりますが、`P`はどうでしょうか？\
`P`はクロージャ、**無名関数**です。名前が示すように、クロージャには名前がないため、コードに書き下すことはできません。

Rustにはこれに対する解決策があります：**impl Trait**です。

## `impl Trait`

`impl Trait`は、その名前を指定せずに型を返すことを可能にする機能です。
型が実装するトレイトを宣言するだけで、Rustが残りを解決します。

この場合、`Ticket`への参照のイテレータを返したいです：

```rust
impl TicketStore {
    pub fn to_dos(&self) -> impl Iterator<Item = &Ticket> {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
```

それだけです！

## ジェネリック？

戻り値位置の`impl Trait`はジェネリックパラメータでは**ありません**。

ジェネリックは、関数の呼び出し元によって埋められる型のプレースホルダーです。
ジェネリックパラメータを持つ関数は**多態的**です：異なる型で呼び出すことができ、コンパイラは各型に対して異なる実装を生成します。

これは`impl Trait`の場合ではありません。
`impl Trait`を持つ関数の戻り値の型はコンパイル時に**固定**されており、コンパイラはそれに対して単一の実装を生成します。
これが`impl Trait`が**不透明戻り値型**とも呼ばれる理由です：呼び出し元は戻り値の正確な型を知らず、指定されたトレイトを実装していることのみを知っています。しかし、コンパイラは正確な型を知っており、多態性は関与していません。

## RPIT

RustのRFCや深く掘り下げた記事を読むと、**RPIT**という略語に遭遇するかもしれません。\
これは**「Return Position Impl Trait」**（戻り値位置Impl Trait）の略で、戻り値位置での`impl Trait`の使用を指します。