# コンビネータ

イテレータは`for`ループ以外にもたくさんのことができます！\
`Iterator`トレイトのドキュメントを見ると、イテレータをさまざまな方法で変換、フィルタ、結合するために活用できる**膨大な**メソッドのコレクションが見つかります。

最も一般的なものを挙げてみましょう：

- `map`は各イテレータの要素に関数を適用します。
- `filter`は述語を満たす要素のみを保持します。
- `filter_map`は`filter`と`map`を一つのステップで組み合わせます。
- `cloned`は参照のイテレータを、各要素をクローンして値のイテレータに変換します。
- `enumerate`は`(index, value)`ペアを返す新しいイテレータを返します。
- `skip`はイテレータの最初の`n`個の要素をスキップします。
- `take`は`n`個の要素の後でイテレータを停止します。
- `chain`は2つのイテレータを1つに結合します。

これらのメソッドは**コンビネータ**と呼ばれます。\
これらは通常**チェーン**されて、簡潔で読みやすい方法で複雑な変換を作成します：

```rust
let numbers = vec![1, 2, 3, 4, 5];
// 偶数の二乗の合計
let outcome: u32 = numbers.iter()
    .filter(|&n| n % 2 == 0)
    .map(|&n| n * n)
    .sum();
```

## クロージャ

上記の`filter`と`map`メソッドで何が起こっているのでしょうか？\
これらは引数として**クロージャ**を取ります。

クロージャは**無名関数**、すなわち慣れ親しんだ`fn`構文を使用して定義されていない関数です。\
これらは`|args| body`構文を使用して定義されます。ここで`args`は引数、`body`は関数本体です。
`body`はコードブロックまたは単一の式にできます。
例：

```rust
// 引数に1を加える無名関数
let add_one = |x| x + 1;
// ブロックでも書けます：
let add_one = |x| { x + 1 };
```

クロージャは複数の引数を取ることができます：

```rust
let add = |x, y| x + y;
let sum = add(1, 2);
```

また、環境から変数をキャプチャすることもできます：

```rust
let x = 42;
let add_x = |y| x + y;
let sum = add_x(1);
```

必要に応じて、引数の型や戻り値の型を指定できます：

```rust
// 入力型のみ
let add_one = |x: i32| x + 1;
// または入力と出力の両方の型、`fn`構文を使用
let add_one: fn(i32) -> i32 = |x| x + 1;
```

## `collect`

コンビネータを使用してイテレータの変換が完了したらどうなるでしょうか？\
`for`ループを使用して変換された値を反復するか、コレクションに収集します。

後者は`collect`メソッドを使用して行われます。\
`collect`はイテレータを消費し、選択したコレクションにその要素を収集します。

例えば、偶数の二乗を`Vec`に収集できます：

```rust
let numbers = vec![1, 2, 3, 4, 5];
let squares_of_evens: Vec<u32> = numbers.iter()
    .filter(|&n| n % 2 == 0)
    .map(|&n| n * n)
    .collect();
```

`collect`は**戻り値の型**に対してジェネリックです。\
したがって、通常はコンパイラが正しい型を推論するのを助けるために型ヒントを提供する必要があります。
上記の例では、`squares_of_evens`の型を`Vec<u32>`として注釈しました。
代わりに、**ターボフィッシュ構文**を使用して型を指定することもできます：

```rust
let squares_of_evens = numbers.iter()
    .filter(|&n| n % 2 == 0)
    .map(|&n| n * n)
    // ターボフィッシュ構文: `<method_name>::<type>()`
    // `::<>`が魚のように見えるためターボフィッシュと呼ばれます
    .collect::<Vec<u32>>();
```

## さらなる読み物

- [`Iterator`のドキュメント](https://doc.rust-lang.org/std/iter/trait.Iterator.html)は`std`でイテレータに利用可能なメソッドの概要を提供します。
- [`itertools`クレート](https://docs.rs/itertools/)はイテレータ用の**さらに多くの**コンビネータを定義します。