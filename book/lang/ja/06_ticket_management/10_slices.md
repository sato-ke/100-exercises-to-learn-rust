# スライス

`Vec`のメモリレイアウトに戻りましょう：

```rust
let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
```

```text
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
```

`String`が単に`Vec<u8>`の変装であることを既に述べました。\
この類似性から質問が生まれるはずです：「`Vec`にとっての`&str`に相当するものは何か？」

## `&[T]`

`[T]`は型`T`の要素の連続したシーケンスの**スライス**です。\
最も一般的に借用形式の`&[T]`で使用されます。

`Vec`からスライス参照を作成するさまざまな方法があります：

```rust
let numbers = vec![1, 2, 3];
// インデックス構文経由
let slice: &[i32] = &numbers[..];
// メソッド経由
let slice: &[i32] = numbers.as_slice();
// または要素のサブセットに対して
let slice: &[i32] = &numbers[1..];
```

`Vec`は`[T]`をターゲット型として使用して`Deref`トレイトを実装しているため、deref強制のおかげで`Vec`上で直接スライスメソッドを使用できます：

```rust
let numbers = vec![1, 2, 3];
// 驚くべきことに：`iter`は`Vec`のメソッドではありません！
// これは`&[T]`のメソッドですが、deref強制のおかげで
// `Vec`上で呼び出すことができます。
let sum: i32 = numbers.iter().sum();
```

### メモリレイアウト

`&[T]`は`&str`と同様に**ファットポインタ**です。\
これはスライスの最初の要素へのポインタとスライスの長さで構成されます。

3つの要素を持つ`Vec`がある場合：

```rust
let numbers = vec![1, 2, 3];
```

そしてスライス参照を作成する場合：

```rust
let slice: &[i32] = &numbers[1..];
```

次のメモリレイアウトが得られます：

```text
                  numbers                          slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   3    |    4     |      |    |    |   2    |
      +----|----+--------+----------+      +----|----+--------+
           |                                    |  
           |                                    |
           v                                    | 
         +---+---+---+---+                      |
Heap:    | 1 | 2 | 3 | ? |                      |
         +---+---+---+---+                      |
               ^                                |
               |                                |
               +--------------------------------+
```

### `&Vec<T>` vs `&[T]`

関数に`Vec`への不変参照を渡す必要がある場合、`&Vec<T>`よりも`&[T]`を好むようにしてください。\
これにより、関数は必ずしも`Vec`に支えられたものではない、あらゆる種類のスライスを受け入れることができます。

例えば、`Vec`内の要素のサブセットを渡すことができます。
しかし、それだけにとどまりません—**配列のスライス**も渡すことができます：

```rust
let array = [1, 2, 3];
let slice: &[i32] = &array;
```

配列スライスと`Vec`スライスは同じ型です：これらは要素の連続したシーケンスへのファットポインタです。
配列の場合、ポインタはヒープではなくスタックを指しますが、スライスを使用する際にはそれは重要ではありません。