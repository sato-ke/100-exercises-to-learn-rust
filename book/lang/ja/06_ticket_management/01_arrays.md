# 配列

「チケット管理」について話し始めるとすぐに、_複数の_チケットを保存する方法について考える必要があります。
つまり、コレクションについて考える必要があります。特に、同質なコレクション：
同じ型の複数のインスタンスを保存したいのです。

この点に関して、Rustは何を提供しているでしょうか？

## 配列

最初の試みとして、**配列**を使用することが考えられます。\
Rustの配列は、同じ型の要素の固定サイズコレクションです。

配列を定義する方法は以下の通りです：

```rust
// 配列型の構文: [ <型> ; <要素数> ]
let numbers: [u32; 3] = [1, 2, 3];
```

これは3つの整数の配列を作成し、値`1`、`2`、`3`で初期化します。\
配列の型は`[u32; 3]`で、これは「長さ3の`u32`の配列」と読みます。

配列のすべての要素が同じ場合、より短い構文で初期化できます：

```rust
// [ <値> ; <要素数> ]
let numbers: [u32; 3] = [1; 3];
```

`[1; 3]`は3つの要素の配列を作成し、すべて`1`に等しくなります。

### 要素へのアクセス

角括弧を使用して配列の要素にアクセスできます：

```rust
let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
```

インデックスは`usize`型である必要があります。\
配列は、Rustの他の要素と同様に**ゼロインデックス**です。これは文字列スライスやタプル/タプル風バリアントのフィールドインデックスで以前に見たことがあります。

### 範囲外アクセス

範囲外の要素にアクセスしようとすると、Rustはパニックします：

```rust
let numbers: [u32; 3] = [1, 2, 3];
let fourth = numbers[3]; // これはパニックします
```

これは**境界チェック**を使用してランタイムで強制されます。わずかなパフォーマンスオーバーヘッドが伴いますが、これがRustがバッファオーバーフローを防ぐ方法です。\
シナリオによっては、特にイテレータが関与している場合、Rustコンパイラは境界チェックを最適化で除去できます。これについては後で詳しく説明します。

パニックしたくない場合は、`get`メソッドを使用できます。これは`Option<&T>`を返します：

```rust
let numbers: [u32; 3] = [1, 2, 3];
assert_eq!(numbers.get(0), Some(&1));
// 範囲外のインデックスにアクセスしようとすると、
// パニックの代わりに`None`が得られます。
assert_eq!(numbers.get(3), None);
```

### パフォーマンス

配列のサイズはコンパイル時に分かっているため、コンパイラは配列をスタックに割り当てることができます。
以下のコードを実行すると：

```rust
let numbers: [u32; 3] = [1, 2, 3];
```

次のメモリレイアウトが得られます：

```text
        +---+---+---+
Stack:  | 1 | 2 | 3 |
        +---+---+---+
```

つまり、配列のサイズは`std::mem::size_of::<T>() * N`です。ここで、`T`は要素の型、`N`は要素数です。\
各要素に`O(1)`時間でアクセスし、置き換えることができます。