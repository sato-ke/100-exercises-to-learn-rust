# `HashMap`

我々の`Index`/`IndexMut`の実装は理想的ではありません：IDでチケットを取得するために全体の
`Vec`を反復する必要があり、アルゴリズムの複雑度は`O(n)`です。ここで
`n`はストア内のチケット数です。

チケットを保存するために異なるデータ構造を使用することでより良くできます：`HashMap<K, V>`。

```rust
use std::collections::HashMap;

// 型推論により、明示的な型シグネチャを省略できます（この例では
// `HashMap<String, String>`になります）。
let mut book_reviews = HashMap::new();

book_reviews.insert(
    "Adventures of Huckleberry Finn".to_string(),
    "My favorite book.".to_string(),
);
```

`HashMap`はキー値ペアで動作します。両方に対してジェネリックです：`K`はキー型のジェネリック
パラメータ、`V`は値型のパラメータです。

挿入、取得、削除の期待コストは**定数**の`O(1)`です。
これは我々のユースケースにとって完璧に聞こえませんか？

## キーの要件

`HashMap`の構造体定義にはトレイト境界はありませんが、そのメソッドにはいくつか見つかります。例えば`insert`を見てみましょう：

```rust
// 若干簡略化
impl<K, V> HashMap<K, V>
where
    K: Eq + Hash,
{
    pub fn insert(&mut self, k: K, v: V) -> Option<V> {
        // [...]
    }
}
```

キー型は`Eq`と`Hash`トレイトを実装しなければなりません。\
この2つを詳しく見てみましょう。

## `Hash`

ハッシュ関数（またはハッシャー）は、潜在的に無限の値の集合（例：
すべての可能な文字列）を有界な範囲（例：`u64`値）にマップします。\
多くの異なるハッシュ関数があり、それぞれ異なる特性を持ちます
（速度、衝突リスク、可逆性など）。

`HashMap`は、名前が示すように、内部でハッシュ関数を使用します。
キーをハッシュし、そのハッシュを使用して関連する値を保存/取得します。
この戦略により、キー型はハッシュ可能である必要があり、したがって`K`に`Hash`トレイト境界があります。

`Hash`トレイトは`std::hash`モジュールにあります：

```rust
pub trait Hash {
    // 必須メソッド
    fn hash<H>(&self, state: &mut H)
       where H: Hasher;
}
```

`Hash`を手動で実装することはほとんどありません。ほとんどの場合、派生します：

```rust
#[derive(Hash)]
struct Person {
    id: u32,
    name: String,
}
```

## `Eq`

`HashMap`はキーの等価性を比較できる必要があります。これは特に
ハッシュ衝突を扱う際に重要です—すなわち、2つの異なるキーが同じ値にハッシュされる場合。

疑問に思うかもしれません：それが`PartialEq`トレイトの目的ではないでしょうか？ほぼそうです！\
`PartialEq`は反射性を保証しないため、`HashMap`には十分ではありません。すなわち`a == a`が常に`true`であることを保証しません。\
例えば、浮動小数点数（`f32`と`f64`）は`PartialEq`を実装しますが、
反射性プロパティを満たしません：`f32::NAN == f32::NAN`は`false`です。\
反射性は`HashMap`が正しく動作するために重要です：これなしに、値を
挿入するために使用したのと同じキーを使用してマップから値を取得することができません。

`Eq`トレイトは反射性プロパティで`PartialEq`を拡張します：

```rust
pub trait Eq: PartialEq {
    // 追加のメソッドなし
}
```

これはマーカートレイトです：新しいメソッドを追加せず、単に
`PartialEq`で実装された等価性ロジックが反射的であることをコンパイラに伝える方法です。

`PartialEq`を派生するときに`Eq`を自動的に派生できます：

```rust
#[derive(PartialEq, Eq)]
struct Person {
    id: u32,
    name: String,
}
```

## `Eq`と`Hash`は関連している

`Eq`と`Hash`の間には暗黙の契約があります：2つのキーが等しい場合、それらのハッシュも等しくなければなりません。
これは`HashMap`が正しく動作するために重要です。この契約を破ると、`HashMap`を使用する際に無意味な結果が得られます。