# 型、パート1

[「構文」セクション](../01_intro/01_syntax.md)では、`compute`の入力パラメータは`u32`型でした。\
これが何を_意味する_のか詳しく見ていきましょう。

## プリミティブ型

`u32`はRustの**プリミティブ型**の1つです。プリミティブ型は言語の最も基本的な構成要素です。
それらは言語自体に組み込まれています。つまり、他の型を使って定義されているわけではありません。

これらのプリミティブ型を組み合わせて、より複雑な型を作成できます。その方法についてはすぐに見ていきます。

## 整数

特に`u32`は、**符号なし32ビット整数**です。

整数は、小数部分なしで書ける数値です。例えば、`1`は整数ですが、`1.2`は整数ではありません。

### 符号付き vs. 符号なし

整数は**符号付き**または**符号なし**にできます。\
符号なし整数は非負の数値（つまり`0`以上）のみを表現できます。
符号付き整数は正の数と負の数の両方を表現できます（例：`-1`、`12`など）。

`u32`の`u`は**unsigned（符号なし）**の略です。\
符号付き整数の同等の型は`i32`で、`i`はinteger（整数、つまり正または負の任意の整数）の略です。

### ビット幅

`u32`の`32`は、メモリ内で数値を表現するために使用される**ビット数[^bit]**を指します。\
ビット数が多いほど、表現できる数値の範囲が大きくなります。

Rustは複数のビット幅の整数をサポートしています：`8`、`16`、`32`、`64`、`128`。

32ビットでは、`u32`は`0`から`2^32 - 1`（別名[`u32::MAX`](https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX)）までの数値を表現できます。\
同じビット数で、符号付き整数（`i32`）は`-2^31`から`2^31 - 1`
（つまり[`i32::MIN`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN)
から[`i32::MAX`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX)）までの数値を表現できます。\
`i32`の最大値が`u32`の最大値より小さいのは、1ビットが数値の符号を表現するために使用されるためです。符号付き整数がメモリ内でどのように表現されるかの詳細については、[2の補数](https://ja.wikipedia.org/wiki/2%E3%81%AE%E8%A3%9C%E6%95%B0)表現を確認してください。

### まとめ

2つの変数（符号付き/符号なしとビット幅）を組み合わせると、以下の整数型が得られます：

| ビット幅 | 符号付き | 符号なし |
| --------- | ------ | -------- |
| 8ビット   | `i8`   | `u8`     |
| 16ビット  | `i16`  | `u16`    |
| 32ビット  | `i32`  | `u32`    |
| 64ビット  | `i64`  | `u64`    |
| 128ビット | `i128` | `u128`   |

## リテラル

**リテラル**は、ソースコード内で固定値を表現するための記法です。\
例えば、`42`は数値42のRustリテラルです。

### リテラルの型注釈

しかし、Rustのすべての値には型があるので... `42`の型は何でしょうか？

Rustコンパイラは、使用方法に基づいてリテラルの型を推論しようとします。\
コンテキストを提供しない場合、コンパイラは整数リテラルのデフォルトとして`i32`を使用します。\
別の型を使用したい場合は、目的の整数型を接尾辞として追加できます。例えば、`2u64`は明示的に`u64`として型付けされた2です。

### リテラル内のアンダースコア

大きな数値の可読性を向上させるために、アンダースコア`_`を使用できます。\
例えば、`1_000_000`は`1000000`と同じです。

## 算術演算子

Rustは整数に対して以下の算術演算子[^traits]をサポートしています：

- `+` 加算
- `-` 減算
- `*` 乗算
- `/` 除算
- `%` 剰余

これらの演算子の優先順位と結合規則は数学と同じです。\
デフォルトの優先順位を上書きするために括弧を使用できます。例：`2 * (3 + 4)`。

> ⚠️ **警告**
>
> 除算演算子`/`は、整数型で使用されると整数除算を実行します。
> つまり、結果はゼロに向かって切り捨てられます。例えば、`5 / 2`は`2.5`ではなく`2`です。

## 自動型変換なし

前の演習で説明したように、Rustは静的型付け言語です。\
特に、Rustは型変換についてかなり厳格です。たとえ変換が無損失であっても、ある型から別の型への値の自動変換は行いません[^coercion]。
明示的に行う必要があります。

例えば、すべての`u8`値が有効な`u32`値であっても、`u8`値を`u32`型の変数に代入することはできません：

```rust
let b: u8 = 100;
let a: u32 = b;
```

これはコンパイルエラーになります：

```text
error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
```

型間の変換方法については[このコースの後半](../04_traits/09_from.md)で見ていきます。

## 参考資料

- 公式Rustブックの[整数型セクション](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types)

[^bit]: ビットはコンピュータにおける最小のデータ単位です。`0`または`1`の2つの値しか持てません。

[^traits]: Rustではカスタム演算子を定義することはできませんが、組み込み演算子の動作を制御することはできます。
演算子オーバーロードについては、トレイトをカバーした後で[コースの後半](../04_traits/03_operator_overloading.md)で説明します。

[^coercion]: この規則にはいくつかの例外があり、主に参照、スマートポインタ、人間工学に関連しています。それらについては[後で](../04_traits/07_deref.md)カバーします。
当面は「すべての変換は明示的」という心的モデルが役立つでしょう。