# 変数

Rustでは、`let`キーワードを使用して**変数**を宣言できます。\
例えば：

```rust
let x = 42;
```

上記では、変数`x`を定義し、値`42`を代入しました。

## 型

Rustのすべての変数には型が必要です。型はコンパイラによって推論されるか、開発者によって明示的に指定されます。

### 明示的な型注釈

変数名の後にコロン`:`とそれに続く型を追加することで、変数の型を指定できます。例えば：

```rust
// let <変数名>: <型> = <式>;
let x: u32 = 42;
```

上記の例では、`x`の型を`u32`に明示的に制約しました。

### 型推論

変数の型を指定しない場合、コンパイラは変数が使用されるコンテキストに基づいて型を推論しようとします。

```rust
let x = 42;
let y: u32 = x;
```

上記の例では、`x`の型を指定しませんでした。\
`x`は後で`y`に代入され、`y`は明示的に`u32`として型付けされています。Rustは自動的な型変換を行わないため、
コンパイラは`x`の型を`u32`と推論します。これは`y`と同じ型であり、プログラムがエラーなしでコンパイルできる唯一の型です。

### 推論の制限

コンパイラは時として、使用方法に基づいて正しい変数の型を推論するために少しの助けが必要です。\
そのような場合、コンパイルエラーが発生し、コンパイラは曖昧さを解消するために明示的な型ヒントを提供するよう求めます。

## 関数の引数も変数

すべての英雄がマントを着ているわけではないように、すべての変数が`let`で宣言されるわけではありません。\
関数の引数も変数です！

```rust
fn add_one(x: u32) -> u32 {
    x + 1
}
```

上記の例では、`x`は`u32`型の変数です。\
`x`と`let`で宣言された変数の唯一の違いは、関数の引数は**必ず**型を明示的に宣言しなければならないことです。コンパイラはそれを推論しません。\
この制約により、Rustコンパイラ（そして私たち人間も！）は実装を見ることなく関数のシグネチャを理解できます。これはコンパイル速度の大きな向上につながります[^speed]！

## 初期化

変数を宣言するときに初期化する必要はありません。\
例えば

```rust
let x: u32;
```

は有効な変数宣言です。\
ただし、変数を使用する前に初期化する必要があります。初期化しないとコンパイラがエラーを出します：

```rust
let x: u32;
let y = x + 1;
```

はコンパイルエラーになります：

```text
error[E0381]: used binding `x` isn't initialized
 --> src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
```

[^speed]: Rustコンパイラはコンパイル速度に関して、得られるすべての助けが必要です。