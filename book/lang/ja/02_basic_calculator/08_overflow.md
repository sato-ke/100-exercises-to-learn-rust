# オーバーフロー

数値の階乗は非常に速く大きくなります。
例えば、20の階乗は2,432,902,008,176,640,000です。これは32ビット整数の最大値2,147,483,647よりもすでに大きいです。

算術演算の結果が特定の整数型の最大値より大きい場合、**整数オーバーフロー**について話しています。

整数オーバーフローは、算術演算の契約に違反するため問題です。
特定の型の2つの整数間の算術演算の結果は、同じ型の別の整数であるべきです。
しかし、_数学的に正しい結果_はその整数型に収まりません！

> 結果が特定の整数型の最小値より小さい場合、そのイベントを**整数アンダーフロー**と呼びます。
> 簡潔にするため、このセクションの残りでは整数オーバーフローについてのみ話しますが、
> 言及することはすべて整数アンダーフローにも適用されることに留意してください。
>
> ["変数"セクション](02_variables.md)で書いた`speed`関数は、一部の入力の組み合わせでアンダーフローしました。
> 例えば、`end`が`start`より小さい場合、`end - start`は`u32`型でアンダーフローします。
> なぜなら、結果は負になるはずですが、`u32`は負の数を表現できないからです。

## 自動昇格なし

1つの可能なアプローチは、結果をより大きな整数型に自動的に昇格させることです。
例えば、2つの`u8`整数を合計し、結果が256（`u8::MAX + 1`）の場合、Rustは結果を256を保持できる次の整数型である`u16`として解釈することを選択できます。

しかし、前に説明したように、Rustは型変換についてかなり厳格です。自動整数昇格は、Rustの整数オーバーフロー問題に対する解決策ではありません。

## 代替案

自動昇格を除外したので、整数オーバーフローが発生したときに何ができるでしょうか？
それは2つの異なるアプローチに帰着します：

- 操作を拒否する
- 期待される整数型に収まる「合理的な」結果を考え出す

### 操作を拒否する

これは最も保守的なアプローチです：整数オーバーフローが発生したときにプログラムを停止します。
これは、["パニック"セクション](04_panics.md)ですでに見たメカニズムであるパニックを介して行われます。

### 「合理的な」結果を考え出す

算術演算の結果が特定の整数型の最大値より大きい場合、**ラップアラウンド**を選択できます。
特定の整数型のすべての可能な値を円として考えると、ラップアラウンドは最大値に達したときに最小値から再び始めることを意味します。

例えば、1と255（=`u8::MAX`）の間で**ラッピング加算**を行うと、結果は0（=`u8::MIN`）になります。
符号付き整数で作業している場合も、同じ原則が適用されます。例えば、ラッピングで127（=`i8::MAX`）に1を加えると、-128（=`i8::MIN`）になります。

## `overflow-checks`

Rustは、整数オーバーフローが発生したときに使用するアプローチを開発者であるあなたに選択させます。
動作は`overflow-checks`プロファイル設定によって制御されます。

`overflow-checks`が`true`に設定されている場合、Rustは整数演算がオーバーフローしたときに**実行時にパニック**します。
`overflow-checks`が`false`に設定されている場合、Rustは整数演算がオーバーフローしたときに**ラップアラウンド**します。

プロファイル設定とは何か疑問に思うかもしれません。詳しく見てみましょう！

## プロファイル

[**プロファイル**](https://doc.rust-lang.org/cargo/reference/profiles.html)は、Rustコードのコンパイル方法をカスタマイズするために使用できる設定オプションのセットです。

Cargoは4つの組み込みプロファイルを提供しています：`dev`、`release`、`test`、`bench`。
`dev`プロファイルは、`cargo build`、`cargo run`、または`cargo test`を実行するたびに使用されます。ローカル開発を目的としているため、
より高速なコンパイル時間とより良いデバッグ体験を優先して、実行時のパフォーマンスを犠牲にします。
一方、`release`プロファイルは実行時のパフォーマンスに最適化されていますが、より長いコンパイル時間がかかります。
`--release`フラグを介して明示的に要求する必要があります—例：`cargo build --release`または`cargo run --release`。
`test`プロファイルは`cargo test`で使用されるデフォルトプロファイルです。`test`プロファイルは`dev`プロファイルから設定を継承します。
`bench`プロファイルは`cargo bench`で使用されるデフォルトプロファイルです。`bench`プロファイルは`release`プロファイルから継承します。
反復開発とデバッグには`dev`を、最適化された本番ビルドには`release`を、
正確性テストには`test`を、パフォーマンスベンチマーキングには`bench`を使用してください。

> 「プロジェクトをリリースモードでビルドしましたか？」はRustコミュニティでほぼミームです。
> これは、Rustに慣れていない開発者がソーシャルメディア（例：Reddit、Twitter）でそのパフォーマンスについて
> 文句を言い、プロジェクトをリリースモードでビルドしていないことに気づく前のことを指しています。

カスタムプロファイルを定義したり、組み込みのものをカスタマイズしたりすることもできます。

### `overflow-check`

デフォルトでは、`overflow-checks`は次のように設定されています：

- `dev`プロファイルでは`true`
- `release`プロファイルでは`false`

これは2つのプロファイルの目標に沿っています。
`dev`はローカル開発を目的としているため、潜在的な問題をできるだけ早く強調するためにパニックします。
一方、`release`は実行時のパフォーマンスに調整されています：オーバーフローをチェックするとプログラムが遅くなるため、
ラップアラウンドを選択します。

同時に、2つのプロファイルで異なる動作をすることは、微妙なバグにつながる可能性があります。
両方のプロファイルで`overflow-checks`を有効にすることをお勧めします：静かに不正な結果を生成するよりもクラッシュする方が良いです。
ほとんどの場合、実行時のパフォーマンスへの影響は無視できます。パフォーマンスクリティカルなアプリケーションで作業している場合は、
ベンチマークを実行して、それが許容できるかどうかを判断できます。

## さらに読む

- Rustの整数オーバーフローについての詳細な議論については、["Rustの整数オーバーフローに関する神話と伝説"](https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/)をチェックしてください。