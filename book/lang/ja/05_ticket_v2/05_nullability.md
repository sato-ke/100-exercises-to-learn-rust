# Null許容性

`assigned`メソッドの実装はかなり鈍器的です：To-DoチケットとDoneチケットでpanicするのは理想的とは言えません。  
**RustのOption型**を使用してより良い方法があります。

## `Option`

`Option`は**null許容値**を表すRust型です。  
これは、Rustの標準ライブラリで定義されたenumです：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

`Option`は、値が存在する可能性（`Some(T)`）または存在しない可能性（`None`）があるという考えをエンコードします。  
また、**両方のケースを明示的に処理する**ことを強制します。null許容値を扱っていて`None`ケースの処理を忘れた場合、コンパイラエラーが発生します。  
これは、他の言語の「暗黙的な」null許容性に対する大きな改善です。他の言語では`null`チェックを忘れて、ランタイムエラーを引き起こす可能性があります。

## `Option`の定義

`Option`の定義は、これまで見たことのないRust構文を使用しています：**タプル風バリアント**。

### タプル風バリアント

`Option`には2つのバリアントがあります：`Some(T)`と`None`です。  
`Some`は**タプル風バリアント**です：**無名フィールド**を保持するバリアントです。

タプル風バリアントは、特に`Option`のような「ラッパー」型を見ている場合、保存するフィールドが単一の場合によく使用されます。

### タプル風構造体

これらはenumに限定されるものではありません。タプル風構造体も定義できます：

```rust
struct Point(i32, i32);
```

その後、位置インデックスを使用して`Point`インスタンスの2つのフィールドにアクセスできます：

```rust
let point = Point(3, 4);
let x = point.0;
let y = point.1;
```

### タプル

タプルをまだ見ていないのに、何かがタプル風だと言うのは奇妙です！  
タプルは、プリミティブなRust型のもう一つの例です。  
（潜在的に異なる）型を持つ固定数の値をグループ化します：

```rust
// 2つの値、同じ型
let first: (i32, i32) = (3, 4);
// 3つの値、異なる型
let second: (i32, u32, u8) = (-42, 3, 8);
```

構文は簡単です：括弧の間に値の型をコンマで区切って列挙します。  
ドット記法とフィールドインデックスを使用してタプルのフィールドにアクセスできます：

```rust
assert_eq!(second.0, -42);
assert_eq!(second.1, 3);
assert_eq!(second.2, 8);
```

タプルは、専用の構造体型を定義するのが面倒な場合に、値をグループ化する便利な方法です。