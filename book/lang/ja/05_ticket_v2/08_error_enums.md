# エラーenum

前の演習での解答は少し不格好に感じたかもしれません：文字列でのマッチングは理想的ではありません！  
同僚が`Ticket::new`によって返されるエラーメッセージ（例：可読性を向上させるため）を書き直すと、突然、呼び出しコードが壊れる可能性があります。

これを修正するために必要な仕組みはすでに知っています：enumです！

## エラーへの反応

発生した特定のエラーに基づいて呼び出し元が異なる動作をすることを許可したい場合、enumを使用してさまざまなエラーケースを表現できます：

```rust
// 文字列から`u32`を解析する際に発生する可能性がある
// さまざまなエラーケースを表すエラーenum
enum U32ParseError {
    NotANumber,
    TooLarge,
    Negative,
}
```

エラーenumを使用することで、さまざまなエラーケースを型システムでエンコードしています。これらは失敗可能な関数のシグネチャの一部になります。  
これにより、`match`式を使用してさまざまなエラーケースに反応できるため、呼び出し元のエラーハンドリングが簡素化されます：

```rust
match s.parse_u32() {
    Ok(n) => n,
    Err(U32ParseError::Negative) => 0,
    Err(U32ParseError::TooLarge) => u32::MAX,
    Err(U32ParseError::NotANumber) => {
        panic!("Not a number: {}", s);
    }
}
```