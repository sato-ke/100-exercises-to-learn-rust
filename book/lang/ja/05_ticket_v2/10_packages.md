# ライブラリとバイナリ

`TicketNewError`に`Error`トレイトを実装するのに少しコードが必要でしたね。  
手動の`Display`実装と、`Error`のimplブロック。

[`thiserror`](https://docs.rs/thiserror/latest/thiserror/)というRustクレートを使用することで、ボイラープレートの一部を削除できます。これは、カスタムエラー型の作成を簡素化する**手続きマクロ**を提供します。  
しかし、先走りすぎています：`thiserror`はサードパーティクレートで、初めての依存関係になります！

依存関係について詳しく説明する前に、Rustのパッケージングシステムについて話すために一歩下がりましょう。

## パッケージとは何ですか？

Rustパッケージは、`Cargo.toml`ファイル（**マニフェスト**とも呼ばれます）の`[package]`セクションで定義されます。  
`[package]`内では、名前やバージョンなど、パッケージのメタデータを設定できます。

このセクションの演習のディレクトリにある`Cargo.toml`ファイルを確認してください！

## クレートとは何ですか？

パッケージ内には、**ターゲット**とも呼ばれる一つ以上の**クレート**を持つことができます。  
最も一般的なクレート型は**バイナリクレート**と**ライブラリクレート**です。

### バイナリ

バイナリは**実行可能ファイル**にコンパイルできるプログラムです。  
`main`という名前の関数（プログラムのエントリポイント）を含む必要があります。`main`はプログラムが実行されるときに呼び出されます。

### ライブラリ

一方、ライブラリは単独では実行できません。ライブラリを_実行_することはできませんが、それに依存する他のパッケージから_そのコードをインポート_することはできます。  
ライブラリは、他のパッケージが**依存関係**として活用できるコード（つまり、関数、型など）をグループ化します。

これまで解決したすべての演習は、テストスイートが添付されたライブラリとして構成されています。

### 慣習

覚えておく必要があるRustパッケージに関するいくつかの慣習があります：

- パッケージのソースコードは通常`src`ディレクトリに配置されます。
- `src/lib.rs`ファイルがある場合、`cargo`はパッケージにライブラリクレートが含まれていると推論します。
- `src/main.rs`ファイルがある場合、`cargo`はパッケージにバイナリクレートが含まれていると推論します。

`Cargo.toml`ファイルでターゲットを明示的に宣言することで、これらのデフォルトをオーバーライドできます。詳細については[`cargo`のドキュメント](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets)を参照してください。

パッケージに複数のクレートを含めることはできますが、ライブラリクレートは一つしか含めることができないことを覚えておいてください。