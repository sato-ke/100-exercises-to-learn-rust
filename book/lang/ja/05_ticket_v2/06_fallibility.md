# 失敗可能性

前の演習から`Ticket::new`関数を再考してみましょう：

```rust
impl Ticket {
    pub fn new(
        title: String, 
        description: String, 
        status: Status
    ) -> Ticket {
        if title.is_empty() {
            panic!("Title cannot be empty");
        }
        if title.len() > 50 {
            panic!("Title cannot be longer than 50 bytes");
        }
        if description.is_empty() {
            panic!("Description cannot be empty");
        }
        if description.len() > 500 {
            panic!("Description cannot be longer than 500 bytes");
        }

        Ticket {
            title,
            description,
            status,
        }
    }
}
```

チェックの一つでも失敗すると、関数はpanicします。  
これは理想的ではありません。呼び出し元に**エラーを処理する**機会を与えないからです。

Rustのエラーハンドリングの主要メカニズムである`Result`型を導入する時が来ました。

## `Result`型

`Result`型は、標準ライブラリで定義されたenumです：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

2つのバリアントがあります：

- `Ok(T)`：成功した操作を表します。操作の出力である`T`を保持します。
- `Err(E)`：失敗した操作を表します。発生したエラーである`E`を保持します。

`Ok`と`Err`の両方がジェネリックで、成功ケースとエラーケースに対して独自の型を指定できます。

## 例外なし

Rustでの回復可能なエラーは**値として表現**されます。  
これらは他の値と同様に、型のインスタンスとして渡され、操作されます。  
これは、**例外**を使用してエラーを通知するPythonやC#などの他の言語との大きな違いです。

例外は、推論が困難な別の制御フローパスを作成します。  
関数のシグネチャを見ただけでは、例外をスローできるかどうかわかりません。  
関数のシグネチャを見ただけでは、**どの**例外型をスローできるかわかりません。  
これを知るためには、関数のドキュメントを読むか、実装を見る必要があります。

例外処理ロジックは局所性が非常に悪いです：例外をスローするコードと、それをキャッチするコードは遠く離れており、両者の間に直接的なリンクがありません。

## 失敗可能性は型システムでエンコードされる

Rustは`Result`を使用して、**関数のシグネチャに失敗可能性をエンコードする**ことを強制します。  
関数が失敗する可能性がある場合（そして呼び出し元にエラーを処理する機会を与えたい場合）、`Result`を返す必要があります。

```rust
// シグネチャを見ただけで、この関数が
// 失敗する可能性があることがわかります。また、`ParseIntError`を調べて
// どのような失敗を期待すべきかを確認できます。
fn parse_int(s: &str) -> Result<i32, ParseIntError> {
    // ...
}
```

これが`Result`の大きな利点です：失敗可能性を明示的にします。

ただし、panicが存在することを忘れないでください。他の言語の例外と同様に、型システムによって追跡されません。  
しかし、これらは**回復不可能なエラー**を意図しており、控えめに使用すべきです。